/* This file is part of GDB.

   Copyright 2002, 2007 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   --

   This file was generated by the program igen */

#ifndef SEMANTICS_C
#define SEMANTICS_C


#include "sim-inline.c"

#if C_REVEALS_MODULE_P (ITABLE_INLINE)
#include "itable.c"
#else
#include "itable.h"
#endif

#if C_REVEALS_MODULE_P (IDECODE_INLINE)
#include "idecode.c"
#else
#include "idecode.h"
#endif

#if C_REVEALS_MODULE_P (SUPPORT_INLINE)
#include "support.c"
#else
#include "support.h"
#endif

#include "semantics.h"


EXTERN_SEMANTICS\
(instruction_address)
semantic_RSVD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSVD_SPECIAL
#undef RSVD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX RSVD_SPECIAL
#undef MY_NAME
#define MY_NAME "RSVD_SPECIAL"

  /* Extraction: RSVD
       #define do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 70 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 95 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsvd %ld", \
                    (long) OP);
#line 87 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSVD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 97 "../.././sim/mips/mips.igen"
    SignalException (ReservedInstruction, instruction_0);
  }
#line 115 "semantics.c"
  return nia;
  /* Extraction: RSVD
       #undef do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#line 122 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYSCALL_SPECIAL (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYSCALL_SPECIAL
#undef SYSCALL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYSCALL_SPECIAL
#undef MY_NAME
#define MY_NAME "SYSCALL_SPECIAL"

  /* Extraction: SYSCALL
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 145 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xc */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3787 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "syscall %#lx", \
                    (unsigned long) CODE);
#line 162 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYSCALL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3801 "../.././sim/mips/mips.igen"
    SignalException (SystemCall, instruction_0);
  }
#line 190 "semantics.c"
  return nia;
  /* Extraction: SYSCALL
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#line 197 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BREAK_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BREAK_SPECIAL
#undef BREAK_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX BREAK_SPECIAL
#undef MY_NAME
#define MY_NAME "BREAK_SPECIAL"

  /* Extraction: BREAK
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 220 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xd */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1085 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "break %#lx", \
                    (unsigned long) CODE);
#line 237 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BREAK_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1099 "../.././sim/mips/mips.igen"
    /* Check for some break instruction which are reserved for use by the simulator.  */
    unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
    if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
        break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        sim_engine_halt (SD, CPU, NULL, cia,
                         sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
      }
    else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
             break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        if (STATE & simDELAYSLOT)
          PC = cia - 4; /* reference the branch instruction */
        else
          PC = cia;
        SignalException (BreakPoint, instruction_0);
      }

    else
      {
        /* If we get this far, we're not an instruction reserved by the sim.  Raise
    	 the exception. */
        SignalException (BreakPoint, instruction_0);
      }
  }
#line 288 "semantics.c"
  return nia;
  /* Extraction: BREAK
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#line 295 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGE_SPECIAL
#undef TGE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGE_SPECIAL
#undef MY_NAME
#define MY_NAME "TGE_SPECIAL"

  /* Extraction: TGE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 322 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x30 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3842 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tge r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 340 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3854 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 369 "semantics.c"
  return nia;
  /* Extraction: TGE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#undef RT
#undef CODE
#line 378 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEU_SPECIAL
#undef TGEU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGEU_SPECIAL
#undef MY_NAME
#define MY_NAME "TGEU_SPECIAL"

  /* Extraction: TGEU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 405 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x31 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3896 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 423 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3908 "../.././sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 452 "semantics.c"
  return nia;
  /* Extraction: TGEU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#undef RT
#undef CODE
#line 461 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLT_SPECIAL
#undef TLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLT_SPECIAL
#undef MY_NAME
#define MY_NAME "TLT_SPECIAL"

  /* Extraction: TLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 488 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x32 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3914 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlt r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 506 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3926 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 535 "semantics.c"
  return nia;
  /* Extraction: TLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#undef RT
#undef CODE
#line 544 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTU_SPECIAL
#undef TLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "TLTU_SPECIAL"

  /* Extraction: TLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 571 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x33 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3968 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 589 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3980 "../.././sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 618 "semantics.c"
  return nia;
  /* Extraction: TLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#undef RT
#undef CODE
#line 627 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQ_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQ_SPECIAL
#undef TEQ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TEQ_SPECIAL
#undef MY_NAME
#define MY_NAME "TEQ_SPECIAL"

  /* Extraction: TEQ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 654 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x34 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3806 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teq r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 672 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3818 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 701 "semantics.c"
  return nia;
  /* Extraction: TEQ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#undef RT
#undef CODE
#line 710 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNE_SPECIAL
#undef TNE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TNE_SPECIAL
#undef MY_NAME
#define MY_NAME "TNE_SPECIAL"

  /* Extraction: TNE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 737 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x36 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3986 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tne r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 755 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3998 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 784 "semantics.c"
  return nia;
  /* Extraction: TNE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#undef RT
#undef CODE
#line 793 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLV_SPECIAL
#undef SLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLV_SPECIAL"

  /* Extraction: SLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 820 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3393 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 844 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3407 "../.././sim/mips/mips.igen"
    do_sllv (SD_, RS, RT, RD);
  }
#line 872 "semantics.c"
  return nia;
  /* Extraction: SLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#undef RT
#undef RD
#line 881 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRLV_SPECIAL
#undef SRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRLV_SPECIAL"

  /* Extraction: SRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 908 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3618 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 932 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3632 "../.././sim/mips/mips.igen"
    do_srlv (SD_, RS, RT, RD);
  }
#line 960 "semantics.c"
  return nia;
  /* Extraction: SRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#undef RT
#undef RD
#line 969 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRAV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRAV_SPECIAL
#undef SRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRAV_SPECIAL"

  /* Extraction: SRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 996 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3558 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1020 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3572 "../.././sim/mips/mips.igen"
    do_srav (SD_, RS, RT, RD);
  }
#line 1048 "semantics.c"
  return nia;
  /* Extraction: SRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#undef RT
#undef RD
#line 1057 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_SPECIAL
#undef MOVZ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVZ_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVZ_SPECIAL"

  /* Extraction: MOVZ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1084 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2614 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1108 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2623 "../.././sim/mips/mips.igen"
    if (GPR[RT] == 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1140 "semantics.c"
  return nia;
  /* Extraction: MOVZ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#undef RT
#undef RD
#line 1149 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_SPECIAL
#undef MOVN_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVN_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVN_SPECIAL"

  /* Extraction: MOVN
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1176 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2595 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1200 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2604 "../.././sim/mips/mips.igen"
    if (GPR[RT] != 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1232 "semantics.c"
  return nia;
  /* Extraction: MOVN
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#undef RT
#undef RD
#line 1241 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_SPECIAL
#undef ADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADD_SPECIAL
#undef MY_NAME
#define MY_NAME "ADD_SPECIAL"

  /* Extraction: ADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1268 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 508 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1292 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 522 "../.././sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1328 "semantics.c"
  return nia;
  /* Extraction: ADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#undef RT
#undef RD
#line 1337 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDU_SPECIAL
#undef ADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "ADDU_SPECIAL"

  /* Extraction: ADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1364 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 602 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1388 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 616 "../.././sim/mips/mips.igen"
    do_addu (SD_, RS, RT, RD);
  }
#line 1416 "semantics.c"
  return nia;
  /* Extraction: ADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#undef RT
#undef RD
#line 1425 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_SPECIAL
#undef SUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUB_SPECIAL
#undef MY_NAME
#define MY_NAME "SUB_SPECIAL"

  /* Extraction: SUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1452 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3637 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1476 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3651 "../.././sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_SUB (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1512 "semantics.c"
  return nia;
  /* Extraction: SUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#undef RT
#undef RD
#line 1521 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUBU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUBU_SPECIAL
#undef SUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "SUBU_SPECIAL"

  /* Extraction: SUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1548 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3673 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "subu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1572 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3687 "../.././sim/mips/mips.igen"
    do_subu (SD_, RS, RT, RD);
  }
#line 1600 "semantics.c"
  return nia;
  /* Extraction: SUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#undef RT
#undef RD
#line 1609 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_AND_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_AND_SPECIAL
#undef AND_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX AND_SPECIAL
#undef MY_NAME
#define MY_NAME "AND_SPECIAL"

  /* Extraction: AND
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1636 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 629 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "and r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1660 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_AND_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 643 "../.././sim/mips/mips.igen"
    do_and (SD_, RS, RT, RD);
  }
#line 1688 "semantics.c"
  return nia;
  /* Extraction: AND
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#undef RT
#undef RD
#line 1697 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_OR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_OR_SPECIAL
#undef OR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX OR_SPECIAL
#undef MY_NAME
#define MY_NAME "OR_SPECIAL"

  /* Extraction: OR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1724 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2960 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "or r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1748 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_OR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2974 "../.././sim/mips/mips.igen"
    do_or (SD_, RS, RT, RD);
  }
#line 1776 "semantics.c"
  return nia;
  /* Extraction: OR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#undef RT
#undef RD
#line 1785 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XOR_SPECIAL
#undef XOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX XOR_SPECIAL
#undef MY_NAME
#define MY_NAME "XOR_SPECIAL"

  /* Extraction: XOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1812 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4029 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1836 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4043 "../.././sim/mips/mips.igen"
    do_xor (SD_, RS, RT, RD);
  }
#line 1864 "semantics.c"
  return nia;
  /* Extraction: XOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#undef RT
#undef RD
#line 1873 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NOR_SPECIAL
#undef NOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX NOR_SPECIAL
#undef MY_NAME
#define MY_NAME "NOR_SPECIAL"

  /* Extraction: NOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1900 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2934 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1924 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2948 "../.././sim/mips/mips.igen"
    do_nor (SD_, RS, RT, RD);
  }
#line 1952 "semantics.c"
  return nia;
  /* Extraction: NOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#undef RT
#undef RD
#line 1961 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLT_SPECIAL
#undef SLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLT_SPECIAL
#undef MY_NAME
#define MY_NAME "SLT_SPECIAL"

  /* Extraction: SLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1988 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3419 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slt r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2012 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3433 "../.././sim/mips/mips.igen"
    do_slt (SD_, RS, RT, RD);
  }
#line 2040 "semantics.c"
  return nia;
  /* Extraction: SLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#undef RT
#undef RD
#line 2049 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTU_SPECIAL
#undef SLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "SLTU_SPECIAL"

  /* Extraction: SLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2076 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3498 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2100 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3512 "../.././sim/mips/mips.igen"
    do_sltu (SD_, RS, RT, RD);
  }
#line 2128 "semantics.c"
  return nia;
  /* Extraction: SLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#undef RT
#undef RD
#line 2137 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULT_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULT_SPECIAL
#undef MULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULT_SPECIAL
#undef MY_NAME
#define MY_NAME "MULT_SPECIAL"

  /* Extraction: MULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2162 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2814 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2185 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2824 "../.././sim/mips/mips.igen"
    do_mult (SD_, RS, RT, 0);
  }
#line 2213 "semantics.c"
  return nia;
  /* Extraction: MULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#undef RT
#line 2221 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULTU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULTU_SPECIAL
#undef MULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "MULTU_SPECIAL"

  /* Extraction: MULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2246 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x19 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2880 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "multu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2269 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2890 "../.././sim/mips/mips.igen"
    do_multu (SD_, RS, RT, 0);
  }
#line 2297 "semantics.c"
  return nia;
  /* Extraction: MULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#undef RT
#line 2305 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_SPECIAL
#undef DIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DIV_SPECIAL"

  /* Extraction: DIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2330 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1433 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2353 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1447 "../.././sim/mips/mips.igen"
    do_div (SD_, RS, RT);
  }
#line 2381 "semantics.c"
  return nia;
  /* Extraction: DIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#undef RT
#line 2389 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIVU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIVU_SPECIAL
#undef DIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DIVU_SPECIAL"

  /* Extraction: DIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2414 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1474 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "divu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2437 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1488 "../.././sim/mips/mips.igen"
    do_divu (SD_, RS, RT);
  }
#line 2465 "semantics.c"
  return nia;
  /* Extraction: DIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#undef RT
#line 2473 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_SPECIAL
#undef MOVtf_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVtf_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVtf_SPECIAL"

  /* Extraction: MOVtf
       #define do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2502 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000207c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5045 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s r%ld, r%ld, %ld", \
                    str_TF (SD_, TF), \
                    (long) RD, \
                    (long) RS, \
                    (long) CC);
#line 2541 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5054 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      GPR[RD] = GPR[RS];
  }
#line 2571 "semantics.c"
  return nia;
  /* Extraction: MOVtf
       #undef do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#undef CC
#undef TF
#undef RD
#line 2581 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JALR_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JALR_SPECIAL
#undef JALR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JALR_SPECIAL
#undef MY_NAME
#define MY_NAME "JALR_SPECIAL"

  /* Extraction: JALR
       #define do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2606 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 31)
#line 1929 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld", \
                      (long) RS);
#line 2629 "semantics.c"
      else
#line 1930 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld, r%ld", \
                      (long) RD, \
                      (long) RS);
#line 2638 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JALR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1944 "../.././sim/mips/mips.igen"
    address_word temp = GPR[RS];
    GPR[RD] = CIA + 8;
    DELAY_SLOT (temp);
  }
#line 2668 "semantics.c"
  return nia;
  /* Extraction: JALR
       #undef do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#undef RD
#line 2676 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JR_SPECIAL
#undef JR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JR_SPECIAL
#undef MY_NAME
#define MY_NAME "JR_SPECIAL"

  /* Extraction: JR
       #define do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2699 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1961 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jr r%ld", \
                    (long) RS);
#line 2721 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1975 "../.././sim/mips/mips.igen"
    DELAY_SLOT (GPR[RS]);
  }
#line 2749 "semantics.c"
  return nia;
  /* Extraction: JR
       #undef do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#line 2756 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTHI_SPECIAL
#undef MTHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MTHI_SPECIAL"

  /* Extraction: MTHI
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2779 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2715 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mthi r%ld", \
                    (long) RS);
#line 2801 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2727 "../.././sim/mips/mips.igen"
    check_mt_hilo (SD_, HIHISTORY);
    HI = GPR[RS];
  }
#line 2830 "semantics.c"
  return nia;
  /* Extraction: MTHI
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#line 2837 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTLO_SPECIAL
#undef MTLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MTLO_SPECIAL"

  /* Extraction: MTLO
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2860 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x13 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2746 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtlo r%ld", \
                    (long) RS);
#line 2882 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2758 "../.././sim/mips/mips.igen"
    check_mt_hilo (SD_, LOHISTORY);
    LO = GPR[RS];
  }
#line 2911 "semantics.c"
  return nia;
  /* Extraction: MTLO
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#line 2918 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLa_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLa_SPECIAL
#undef SLLa_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLa_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLa_SPECIAL"

  /* Extraction: SLLa
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 2945 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 0 && RT == 0 && SHIFT == 0)
#line 3350 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "nop");
#line 2967 "semantics.c"
      else
#line 3351 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sll r%ld, r%ld, %ld", \
                      (long) RD, \
                      (long) RT, \
                      (long) SHIFT);
#line 2977 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLa_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3361 "../.././sim/mips/mips.igen"
    /* Skip shift for NOP, so that there won't be lots of extraneous
       trace output.  */
    if (RD != 0 || RT != 0 || SHIFT != 0)
      do_sll (SD_, RT, RD, SHIFT);
  }
#line 3008 "semantics.c"
  return nia;
  /* Extraction: SLLa
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#undef RD
#undef SHIFT
#line 3017 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRL_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRL_SPECIAL
#undef SRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRL_SPECIAL
#undef MY_NAME
#define MY_NAME "SRL_SPECIAL"

  /* Extraction: SRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3044 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3588 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3068 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3602 "../.././sim/mips/mips.igen"
    do_srl (SD_, RT, RD, SHIFT);
  }
#line 3096 "semantics.c"
  return nia;
  /* Extraction: SRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#undef RD
#undef SHIFT
#line 3105 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRA_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRA_SPECIAL
#undef SRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRA_SPECIAL
#undef MY_NAME
#define MY_NAME "SRA_SPECIAL"

  /* Extraction: SRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3132 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3527 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3156 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3541 "../.././sim/mips/mips.igen"
    do_sra (SD_, RT, RD, SHIFT);
  }
#line 3184 "semantics.c"
  return nia;
  /* Extraction: SRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#undef RD
#undef SHIFT
#line 3193 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFHI_SPECIAL
#undef MFHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MFHI_SPECIAL"

  /* Extraction: MFHI
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3216 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2525 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfhi r%ld", \
                    (long) RD);
#line 3238 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2537 "../.././sim/mips/mips.igen"
    do_mfhi (SD_, RD);
  }
#line 3266 "semantics.c"
  return nia;
  /* Extraction: MFHI
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#line 3273 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFLO_SPECIAL
#undef MFLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MFLO_SPECIAL"

  /* Extraction: MFLO
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3296 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2564 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mflo r%ld", \
                    (long) RD);
#line 3318 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2576 "../.././sim/mips/mips.igen"
    do_mflo (SD_, RD);
  }
#line 3346 "semantics.c"
  return nia;
  /* Extraction: MFLO
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#line 3353 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYNC_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYNC_SPECIAL
#undef SYNC_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYNC_SPECIAL
#undef MY_NAME
#define MY_NAME "SYNC_SPECIAL"

  /* Extraction: SYNC
       #define do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#define STYPE ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3376 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,15.0x0,5.STYPE,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fff800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (STYPE == 0)
#line 3768 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync");
#line 3398 "semantics.c"
      else
#line 3769 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync %ld", \
                      (long) STYPE);
#line 3406 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYNC_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3782 "../.././sim/mips/mips.igen"
    SyncOperation (STYPE);
  }
#line 3434 "semantics.c"
  return nia;
  /* Extraction: SYNC
       #undef do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#line 3441 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZ_REGIMM
#undef BLTZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZ_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZ_REGIMM"

  /* Extraction: BLTZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3466 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x0,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 928 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3484 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 942 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3516 "semantics.c"
  return nia;
  /* Extraction: BLTZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 3524 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZ_REGIMM
#undef BGEZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZ_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZ_REGIMM"

  /* Extraction: BGEZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3549 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x1,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 720 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3567 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 734 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3599 "semantics.c"
  return nia;
  /* Extraction: BGEZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#undef OFFSET
#line 3607 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZL_REGIMM
#undef BLTZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZL_REGIMM"

  /* Extraction: BLTZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3632 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x2,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1009 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3650 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1022 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3686 "semantics.c"
  return nia;
  /* Extraction: BLTZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#undef OFFSET
#line 3694 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZL_REGIMM
#undef BGEZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZL_REGIMM"

  /* Extraction: BGEZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3719 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x3,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 801 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3737 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 814 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3771 "semantics.c"
  return nia;
  /* Extraction: BGEZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#undef OFFSET
#line 3779 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEI_REGIMM
#undef TGEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEI_REGIMM
#undef MY_NAME
#define MY_NAME "TGEI_REGIMM"

  /* Extraction: TGEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3804 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x8,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3860 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3822 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3872 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3851 "semantics.c"
  return nia;
  /* Extraction: TGEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3859 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEIU_REGIMM
#undef TGEIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEIU_REGIMM
#undef MY_NAME
#define MY_NAME "TGEIU_REGIMM"

  /* Extraction: TGEIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3884 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x9,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3878 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3902 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3890 "../.././sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3931 "semantics.c"
  return nia;
  /* Extraction: TGEIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3939 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTI_REGIMM
#undef TLTI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTI_REGIMM
#undef MY_NAME
#define MY_NAME "TLTI_REGIMM"

  /* Extraction: TLTI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3964 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xa,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3932 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlti r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3982 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3944 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4011 "semantics.c"
  return nia;
  /* Extraction: TLTI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4019 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTIU_REGIMM
#undef TLTIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTIU_REGIMM
#undef MY_NAME
#define MY_NAME "TLTIU_REGIMM"

  /* Extraction: TLTIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4044 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xb,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3950 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4062 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3962 "../.././sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4091 "semantics.c"
  return nia;
  /* Extraction: TLTIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4099 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQI_REGIMM
#undef TEQI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TEQI_REGIMM
#undef MY_NAME
#define MY_NAME "TEQI_REGIMM"

  /* Extraction: TEQI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4124 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xc,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3824 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teqi r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4142 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3836 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4171 "semantics.c"
  return nia;
  /* Extraction: TEQI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4179 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNEI_REGIMM
#undef TNEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TNEI_REGIMM
#undef MY_NAME
#define MY_NAME "TNEI_REGIMM"

  /* Extraction: TNEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4204 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xe,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4004 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tnei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4222 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4016 "../.././sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4251 "semantics.c"
  return nia;
  /* Extraction: TNEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4259 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZAL_REGIMM
#undef BLTZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZAL_REGIMM"

  /* Extraction: BLTZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4284 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x10,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 952 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4302 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 966 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4339 "semantics.c"
  return nia;
  /* Extraction: BLTZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#undef OFFSET
#line 4347 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZAL_REGIMM
#undef BGEZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZAL_REGIMM"

  /* Extraction: BGEZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4372 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x11,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 744 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4390 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 758 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4425 "semantics.c"
  return nia;
  /* Extraction: BGEZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#undef OFFSET
#line 4433 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZALL_REGIMM
#undef BLTZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZALL_REGIMM"

  /* Extraction: BLTZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4458 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x12,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 981 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4476 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 994 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4513 "semantics.c"
  return nia;
  /* Extraction: BLTZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#undef OFFSET
#line 4521 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZALL_REGIMM
#undef BGEZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZALL_REGIMM"

  /* Extraction: BGEZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4546 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x13,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 771 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4564 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 784 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4603 "semantics.c"
  return nia;
  /* Extraction: BGEZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#undef OFFSET
#line 4611 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_J_NORMAL (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_J_NORMAL
#undef J_NORMAL
#undef MY_PREFIX
#define MY_PREFIX J_NORMAL
#undef MY_NAME
#define MY_NAME "J_NORMAL"

  /* Extraction: J
       #define do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4634 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1885 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "j %ld", \
                    (long) INSTR_INDEX);
#line 4651 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_J_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1899 "../.././sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot NIA and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4682 "semantics.c"
  return nia;
  /* Extraction: J
       #undef do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4689 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JAL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JAL_NORMAL
#undef JAL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX JAL_NORMAL
#undef MY_NAME
#define MY_NAME "JAL_NORMAL"

  /* Extraction: JAL
       #define do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4712 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1907 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jal %ld", \
                    (long) INSTR_INDEX);
#line 4729 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JAL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1921 "../.././sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    GPR[31] = CIA + 8;
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4761 "semantics.c"
  return nia;
  /* Extraction: JAL
       #undef do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4768 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQ_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQ_NORMAL
#undef BEQ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQ_NORMAL
#undef MY_NAME
#define MY_NAME "BEQ_NORMAL"

  /* Extraction: BEQ
       #define do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4795 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x4,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 671 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beq r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4814 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 685 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4846 "semantics.c"
  return nia;
  /* Extraction: BEQ
       #undef do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4855 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNE_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNE_NORMAL
#undef BNE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNE_NORMAL
#undef MY_NAME
#define MY_NAME "BNE_NORMAL"

  /* Extraction: BNE
       #define do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4882 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x5,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1036 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bne r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4901 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1050 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4933 "semantics.c"
  return nia;
  /* Extraction: BNE
       #undef do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4942 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZ_NORMAL
#undef BLEZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZ_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZ_NORMAL"

  /* Extraction: BLEZ
       #define do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4967 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x6,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 877 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "blez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4990 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 891 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5024 "semantics.c"
  return nia;
  /* Extraction: BLEZ
       #undef do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5032 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZ_NORMAL
#undef BGTZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZ_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZ_NORMAL"

  /* Extraction: BGTZ
       #define do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5057 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x7,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 826 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5080 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 840 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5112 "semantics.c"
  return nia;
  /* Extraction: BGTZ
       #undef do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5120 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDI_NORMAL
#undef ADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDI_NORMAL
#undef MY_NAME
#define MY_NAME "ADDI_NORMAL"

  /* Extraction: ADDI
       #define do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5147 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x8,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 536 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5166 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 550 "../.././sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (EXTEND16 (IMMEDIATE));
      ALU32_END (GPR[RT]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5202 "semantics.c"
  return nia;
  /* Extraction: ADDI
       #undef do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5211 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDIU_NORMAL
#undef ADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "ADDIU_NORMAL"

  /* Extraction: ADDIU
       #define do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5238 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x9,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 573 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5257 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 587 "../.././sim/mips/mips.igen"
    do_addiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5285 "semantics.c"
  return nia;
  /* Extraction: ADDIU
       #undef do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5294 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTI_NORMAL
#undef SLTI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTI_NORMAL
#undef MY_NAME
#define MY_NAME "SLTI_NORMAL"

  /* Extraction: SLTI
       #define do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5321 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xa,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3445 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slti r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5340 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3459 "../.././sim/mips/mips.igen"
    do_slti (SD_, RS, RT, IMMEDIATE);
  }
#line 5368 "semantics.c"
  return nia;
  /* Extraction: SLTI
       #undef do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5377 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTIU_NORMAL
#undef SLTIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTIU_NORMAL
#undef MY_NAME
#define MY_NAME "SLTIU_NORMAL"

  /* Extraction: SLTIU
       #define do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5404 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xb,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3471 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5423 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3485 "../.././sim/mips/mips.igen"
    do_sltiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5451 "semantics.c"
  return nia;
  /* Extraction: SLTIU
       #undef do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5460 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ANDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ANDI_NORMAL
#undef ANDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ANDI_NORMAL
#undef MY_NAME
#define MY_NAME "ANDI_NORMAL"

  /* Extraction: ANDI
       #define do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5487 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xc,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 649 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "andi r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5506 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ANDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 663 "../.././sim/mips/mips.igen"
    TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
    GPR[RT] = GPR[RS] & IMMEDIATE;
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5536 "semantics.c"
  return nia;
  /* Extraction: ANDI
       #undef do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5545 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ORI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ORI_NORMAL
#undef ORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ORI_NORMAL
#undef MY_NAME
#define MY_NAME "ORI_NORMAL"

  /* Extraction: ORI
       #define do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5572 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xd,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2987 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5591 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3001 "../.././sim/mips/mips.igen"
    do_ori (SD_, RS, RT, IMMEDIATE);
  }
#line 5619 "semantics.c"
  return nia;
  /* Extraction: ORI
       #undef do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5628 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XORI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XORI_NORMAL
#undef XORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX XORI_NORMAL
#undef MY_NAME
#define MY_NAME "XORI_NORMAL"

  /* Extraction: XORI
       #define do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5655 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xe,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4055 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5674 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4069 "../.././sim/mips/mips.igen"
    do_xori (SD_, RS, RT, IMMEDIATE);
  }
#line 5702 "semantics.c"
  return nia;
  /* Extraction: XORI
       #undef do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5711 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LUI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LUI_NORMAL
#undef LUI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LUI_NORMAL
#undef MY_NAME
#define MY_NAME "LUI_NORMAL"

  /* Extraction: LUI
       #define do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5736 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xf,5.0x0,5.RT,16.IMMEDIATE */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2319 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lui r%ld, %#lx", \
                    (long) RT, \
                    (unsigned long) IMMEDIATE);
#line 5759 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LUI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2333 "../.././sim/mips/mips.igen"
    TRACE_ALU_INPUT1 (IMMEDIATE);
    GPR[RT] = EXTEND32 (IMMEDIATE << 16);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5789 "semantics.c"
  return nia;
  /* Extraction: LUI
       #undef do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#undef IMMEDIATE
#line 5797 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_COPz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_COPz_NORMAL
#undef COPz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX COPz_NORMAL
#undef MY_NAME
#define MY_NAME "COPz_NORMAL"

  /* Extraction: COPz
       #define do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef COP_FUN0
#define COP_FUN0 ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef COP_FUN1
#define COP_FUN1 ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef COP_FUN2
#define COP_FUN2 ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5826 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5879 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cop%ld %ld%ld%ld", \
                    (long) ZZ, \
                    (long) COP_FUN0, \
                    (long) COP_FUN1, \
                    (long) COP_FUN2);
#line 5846 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_COPz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5892 "../.././sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 5874 "semantics.c"
  return nia;
  /* Extraction: COPz
       #undef do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#undef COP_FUN0
#undef COP_FUN1
#undef COP_FUN2
#line 5884 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC0_COP0
#undef MFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MFC0_COP0
#undef MY_NAME
#define MY_NAME "MFC0_COP0"

  /* Extraction: MFC0
       #define do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 5911 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5825 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 5935 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5839 "../.././sim/mips/mips.igen"
    TRACE_ALU_INPUT0 ();
    DecodeCoproc (instruction_0);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5965 "semantics.c"
  return nia;
  /* Extraction: MFC0
       #undef do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 5974 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC0_COP0
#undef MTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MTC0_COP0
#undef MY_NAME
#define MY_NAME "MTC0_COP0"

  /* Extraction: MTC0
       #define do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 6001 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5845 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 6025 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5859 "../.././sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6053 "semantics.c"
  return nia;
  /* Extraction: MTC0
       #undef do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 6062 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0F_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0F_COP0
#undef BC0F_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0F_COP0
#undef MY_NAME
#define MY_NAME "BC0F_COP0"

  /* Extraction: BC0F
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6085 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5680 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0f %ld", \
                    (long) OFFSET);
#line 6107 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0F_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5679 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5679:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6136 "semantics.c"
  return nia;
  /* Extraction: BC0F
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#line 6143 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0T_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0T_COP0
#undef BC0T_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0T_COP0
#undef MY_NAME
#define MY_NAME "BC0T_COP0"

  /* Extraction: BC0T
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6166 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x1,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5718 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0t %ld", \
                    (long) OFFSET);
#line 6188 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0T_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5717 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5717:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6217 "semantics.c"
  return nia;
  /* Extraction: BC0T
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#line 6224 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0FL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0FL_COP0
#undef BC0FL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0FL_COP0
#undef MY_NAME
#define MY_NAME "BC0FL_COP0"

  /* Extraction: BC0FL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6247 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x2,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5703 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0fl %ld", \
                    (long) OFFSET);
#line 6269 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0FL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5702 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5702:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6298 "semantics.c"
  return nia;
  /* Extraction: BC0FL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#line 6305 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0TL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0TL_COP0
#undef BC0TL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0TL_COP0
#undef MY_NAME
#define MY_NAME "BC0TL_COP0"

  /* Extraction: BC0TL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6328 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x3,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5732 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0tl %ld", \
                    (long) OFFSET);
#line 6350 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0TL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5731 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5731:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6379 "semantics.c"
  return nia;
  /* Extraction: BC0TL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#line 6386 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBR_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBR_COP0
#undef TLBR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBR_COP0
#undef MY_NAME
#define MY_NAME "TLBR_COP0"

  /* Extraction: TLBR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6407 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5913 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbr");
#line 6428 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5912 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5912:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6457 "semantics.c"
  return nia;
  /* Extraction: TLBR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6463 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWI_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWI_COP0
#undef TLBWI_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWI_COP0
#undef MY_NAME
#define MY_NAME "TLBWI_COP0"

  /* Extraction: TLBWI
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6484 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5928 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwi");
#line 6505 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWI_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5927 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5927:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6534 "semantics.c"
  return nia;
  /* Extraction: TLBWI
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6540 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWR_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWR_COP0
#undef TLBWR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWR_COP0
#undef MY_NAME
#define MY_NAME "TLBWR_COP0"

  /* Extraction: TLBWR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6561 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5943 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwr");
#line 6582 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5942 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5942:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6611 "semantics.c"
  return nia;
  /* Extraction: TLBWR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6617 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBP_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBP_COP0
#undef TLBP_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBP_COP0
#undef MY_NAME
#define MY_NAME "TLBP_COP0"

  /* Extraction: TLBP
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6638 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5898 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbp");
#line 6659 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBP_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5897 "../.././sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5897:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6688 "semantics.c"
  return nia;
  /* Extraction: TLBP
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6694 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RFE_COP0 (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RFE_COP0
#undef RFE_COP0
#undef MY_PREFIX
#define MY_PREFIX RFE_COP0
#undef MY_NAME
#define MY_NAME "RFE_COP0"

  /* Extraction: RFE
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6715 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5864 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rfe");
#line 6736 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RFE_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5874 "../.././sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6764 "semantics.c"
  return nia;
  /* Extraction: RFE
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6770 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ERET_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ERET_COP0
#undef ERET_COP0
#undef MY_PREFIX
#define MY_PREFIX ERET_COP0
#undef MY_NAME
#define MY_NAME "ERET_COP0"

  /* Extraction: ERET
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6791 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5798 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "eret");
#line 6812 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ERET_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5809 "../.././sim/mips/mips.igen"
    if (SR & status_ERL)
      {
        /* Oops, not yet available */
        sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
        NIA = EPC;
        SR &= ~status_ERL;
      }
    else
      {
        NIA = EPC;
        SR &= ~status_EXL;
      }
  }
#line 6851 "semantics.c"
  return nia;
  /* Extraction: ERET
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6857 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC1b_COP1
#undef MFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MFC1b_COP1
#undef MY_NAME
#define MY_NAME "MFC1b_COP1"

  /* Extraction: MFC1b
       #define do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 6884 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x0,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5003 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 6921 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5014 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    GPR[RT] = EXTEND32 (FGR[FS]);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 6951 "semantics.c"
  return nia;
  /* Extraction: MFC1b
       #undef do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 6960 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CFC1b_COP1
#undef CFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CFC1b_COP1
#undef MY_NAME
#define MY_NAME "CFC1b_COP1"

  /* Extraction: CFC1b
       #define do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 6987 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x2,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4491 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7024 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4497 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    if (FS == 0 || FS == 31)
      {
        unsigned_word  fcr = ValueFCR (FS);
        TRACE_ALU_INPUT1 (fcr);
        GPR[RT] = fcr;
      }
    /* else NOP */
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7060 "semantics.c"
  return nia;
  /* Extraction: CFC1b
       #undef do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7069 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC1b_COP1
#undef MTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MTC1b_COP1
#undef MY_NAME
#define MY_NAME "MTC1b_COP1"

  /* Extraction: MTC1b
       #define do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7096 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x4,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5169 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7133 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5180 "../.././sim/mips/mips.igen"
    check_fpu (SD_); 
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  }
#line 7162 "semantics.c"
  return nia;
  /* Extraction: MTC1b
       #undef do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7171 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CTC1b_COP1
#undef CTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CTC1b_COP1
#undef MY_NAME
#define MY_NAME "CTC1b_COP1"

  /* Extraction: CTC1b
       #define do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7198 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x6,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4540 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ctc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7235 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4546 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    TRACE_ALU_INPUT1 (GPR[RT]);
    if (FS == 31)
      StoreFCR (FS, GPR[RT]);
    /* else NOP */
  }
#line 7267 "semantics.c"
  return nia;
  /* Extraction: CTC1b
       #undef do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7276 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC1b_COP1S (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC1b_COP1S
#undef BC1b_COP1S
#undef MY_PREFIX
#define MY_PREFIX BC1b_COP1S
#undef MY_NAME
#define MY_NAME "BC1b_COP1S"

  /* Extraction: BC1b
       #define do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef ND
#define ND ((unsigned) EXTRACTED32 (instruction_0, 17, 17)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7305 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4378 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) OFFSET);
#line 7344 "semantics.c"
      else
#line 4379 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld, %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) CC, \
                      (long) OFFSET);
#line 7355 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC1b_COP1S, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4390 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      {
        address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
        DELAY_SLOT (dest);
      }
    else if (ND)
      {
        NULLIFY_NEXT_INSTRUCTION ();
      }
  }
#line 7392 "semantics.c"
  return nia;
  /* Extraction: BC1b
       #undef do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#undef ND
#undef TF
#undef OFFSET
#line 7402 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_fmt_COP1
#undef ADD_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ADD_fmt_COP1
#undef MY_NAME
#define MY_NAME "ADD_fmt_COP1"

  /* Extraction: ADD.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7433 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4297 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7467 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4311 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7498 "semantics.c"
  return nia;
  /* Extraction: ADD.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7509 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_fmt_COP1
#undef SUB_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SUB_fmt_COP1
#undef MY_NAME
#define MY_NAME "SUB_fmt_COP1"

  /* Extraction: SUB.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7540 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5520 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7574 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5534 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7605 "semantics.c"
  return nia;
  /* Extraction: SUB.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7616 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MUL_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MUL_fmt_COP1
#undef MUL_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MUL_fmt_COP1
#undef MY_NAME
#define MY_NAME "MUL_fmt_COP1"

  /* Extraction: MUL.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7647 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5186 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mul.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7681 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MUL_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5200 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7712 "semantics.c"
  return nia;
  /* Extraction: MUL.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7723 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_fmt_COP1
#undef DIV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX DIV_fmt_COP1
#undef MY_NAME
#define MY_NAME "DIV_fmt_COP1"

  /* Extraction: DIV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7754 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4709 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7788 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4723 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7818 "semantics.c"
  return nia;
  /* Extraction: DIV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7829 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_fmt_COP1
#undef MOVZ_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVZ_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVZ_fmt_COP1"

  /* Extraction: MOVZ.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7860 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5119 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 7894 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5128 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] == 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 7926 "semantics.c"
  return nia;
  /* Extraction: MOVZ.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 7937 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_fmt_COP1
#undef MOVN_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVN_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVN_fmt_COP1"

  /* Extraction: MOVN.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7968 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5094 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 8002 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5103 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] != 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 8034 "semantics.c"
  return nia;
  /* Extraction: MOVN.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 8045 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_C_cond_fmtb_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_C_cond_fmtb_COP1
#undef C_cond_fmtb_COP1
#undef MY_PREFIX
#define MY_PREFIX C_cond_fmtb_COP1
#undef MY_NAME
#define MY_NAME "C_cond_fmtb_COP1"

  /* Extraction: C.cond.fmtb
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 10, 8)) /* cache - extraction */
#undef COND
#define COND ((unsigned) MASKED32 (instruction_0, 3, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8078 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000000c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4416 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) FS, \
                      (long) FT);
#line 8118 "semantics.c"
      else
#line 4417 "../.././sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s %ld, f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) CC, \
                      (long) FS, \
                      (long) FT);
#line 8130 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_C_cond_fmtb_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4428 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
    TRACE_ALU_RESULT (ValueFCR (31));
  }
#line 8162 "semantics.c"
  return nia;
  /* Extraction: C.cond.fmtb
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#undef FT
#undef FS
#undef CC
#undef COND
#undef SFRAME
#line 8174 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_fmt_COP1
#undef MOVtf_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVtf_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVtf_fmt_COP1"

  /* Extraction: MOVtf.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8207 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00020000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5063 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s.%s f%ld, f%ld, %ld", \
                    str_TF (SD_, TF), \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) CC);
#line 8247 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5072 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if (fmt != fmt_ps)
      {
        if (GETFCC(CC) == TF)
    	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
        else
    	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
      }
    else
      {
        unsigned64 fd;
        fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
    				      fmt_ps)),
    		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
    				      fmt_ps)));
        StoreFPR (FD, fmt_ps, fd);
      }
  }
#line 8292 "semantics.c"
  return nia;
  /* Extraction: MOVtf.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#undef CC
#undef TF
#undef FS
#undef FD
#undef SFRAME
#line 8304 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SQRT_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SQRT_fmt_COP1
#undef SQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "SQRT_fmt_COP1"

  /* Extraction: SQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8333 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5500 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8371 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5513 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
  }
#line 8401 "semantics.c"
  return nia;
  /* Extraction: SQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8411 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ABS_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ABS_fmt_COP1
#undef ABS_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ABS_fmt_COP1
#undef MY_NAME
#define MY_NAME "ABS_fmt_COP1"

  /* Extraction: ABS.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8440 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4274 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "abs.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8478 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ABS_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4288 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
  }
#line 8509 "semantics.c"
  return nia;
  /* Extraction: ABS.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8519 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOV_fmt_COP1
#undef MOV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOV_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOV_fmt_COP1"

  /* Extraction: MOV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8548 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5021 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8586 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5035 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, ValueFPR (FS, fmt));
  }
#line 8617 "semantics.c"
  return nia;
  /* Extraction: MOV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8627 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NEG_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NEG_fmt_COP1
#undef NEG_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX NEG_fmt_COP1
#undef MY_NAME
#define MY_NAME "NEG_fmt_COP1"

  /* Extraction: NEG.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8656 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5208 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "neg.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8694 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NEG_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5222 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
  }
#line 8725 "semantics.c"
  return nia;
  /* Extraction: NEG.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8735 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_L_fmt_COP1
#undef ROUND_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_L_fmt_COP1"

  /* Extraction: ROUND.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8764 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5358 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8802 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5369 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 8833 "semantics.c"
  return nia;
  /* Extraction: ROUND.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8843 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_L_fmt_COP1
#undef TRUNC_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_L_fmt_COP1"

  /* Extraction: TRUNC.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8872 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5633 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8910 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5644 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 8941 "semantics.c"
  return nia;
  /* Extraction: TRUNC.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8951 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_L_fmt_COP1 (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_L_fmt_COP1
#undef CEIL_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CEIL_L_fmt_COP1"

  /* Extraction: CEIL.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8980 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4437 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9018 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4448 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 9049 "semantics.c"
  return nia;
  /* Extraction: CEIL.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9059 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_L_fmt_COP1
#undef FLOOR_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_L_fmt_COP1"

  /* Extraction: FLOOR.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9088 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4809 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9126 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4820 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 9157 "semantics.c"
  return nia;
  /* Extraction: FLOOR.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9167 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_W_fmt_COP1
#undef ROUND_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_W_fmt_COP1"

  /* Extraction: ROUND.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9196 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5377 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9234 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5390 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9265 "semantics.c"
  return nia;
  /* Extraction: ROUND.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9275 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_W_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_W_COP1
#undef TRUNC_W_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_W_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_W_COP1"

  /* Extraction: TRUNC.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9304 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5652 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9342 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5665 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9373 "semantics.c"
  return nia;
  /* Extraction: TRUNC.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9383 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_W_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_W_COP1
#undef CEIL_W_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_W_COP1
#undef MY_NAME
#define MY_NAME "CEIL_W_COP1"

  /* Extraction: CEIL.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9412 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4456 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9450 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4469 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9481 "semantics.c"
  return nia;
  /* Extraction: CEIL.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9491 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_W_fmt_COP1
#undef FLOOR_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_W_fmt_COP1"

  /* Extraction: FLOOR.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9520 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4828 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9558 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4841 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9589 "semantics.c"
  return nia;
  /* Extraction: FLOOR.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9599 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RECIP_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RECIP_fmt_COP1
#undef RECIP_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RECIP_fmt_COP1
#undef MY_NAME
#define MY_NAME "RECIP_fmt_COP1"

  /* Extraction: RECIP.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9628 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5343 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "recip.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9666 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RECIP_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5351 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
  }
#line 9696 "semantics.c"
  return nia;
  /* Extraction: RECIP.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9706 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSQRT_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSQRT_fmt_COP1
#undef RSQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RSQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "RSQRT_fmt_COP1"

  /* Extraction: RSQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9735 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5398 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9773 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5406 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
  }
#line 9803 "semantics.c"
  return nia;
  /* Extraction: RSQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9813 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_S_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_S_fmt_COP1
#undef CVT_S_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_S_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_S_fmt_COP1"

  /* Extraction: CVT.S.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9842 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4635 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.s.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9880 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_S_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4649 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_single) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_single));
  }
#line 9913 "semantics.c"
  return nia;
  /* Extraction: CVT.S.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9923 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_D_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_D_fmt_COP1
#undef CVT_D_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_D_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_D_fmt_COP1"

  /* Extraction: CVT.D.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9952 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4573 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.d.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9990 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_D_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4587 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_double) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_double));
  }
#line 10023 "semantics.c"
  return nia;
  /* Extraction: CVT.D.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10033 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_W_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_W_fmt_COP1
#undef CVT_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_W_fmt_COP1"

  /* Extraction: CVT.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10062 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4685 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10100 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4699 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 10133 "semantics.c"
  return nia;
  /* Extraction: CVT.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10143 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_L_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_L_fmt_COP1
#undef CVT_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_L_fmt_COP1"

  /* Extraction: CVT.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10172 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4597 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10210 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4608 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_long, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 10243 "semantics.c"
  return nia;
  /* Extraction: CVT.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10253 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MADD_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MADD_fmt_COP1X
#undef MADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MADD_fmt_COP1X"

  /* Extraction: MADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10286 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4972 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "madd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 10321 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4980 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0); 
    StoreFPR (FD, fmt, MultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				  ValueFPR (FR, fmt), fmt));
  }
#line 10354 "semantics.c"
  return nia;
  /* Extraction: MADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 10366 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MSUB_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MSUB_fmt_COP1X
#undef MSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MSUB_fmt_COP1X"

  /* Extraction: MSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10399 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5137 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "msub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 10434 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5145 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, MultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				  ValueFPR (FR, fmt), fmt));
  }
#line 10467 "semantics.c"
  return nia;
  /* Extraction: MSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 10479 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMADD_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMADD_fmt_COP1X
#undef NMADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMADD_fmt_COP1X"

  /* Extraction: NMADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10512 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5230 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmadd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 10547 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5238 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, NegMultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				     ValueFPR (FR, fmt), fmt));
  }
#line 10580 "semantics.c"
  return nia;
  /* Extraction: NMADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 10592 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMSUB_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMSUB_fmt_COP1X
#undef NMSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMSUB_fmt_COP1X"

  /* Extraction: NMSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10625 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5248 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmsub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 10660 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5256 "../.././sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, NegMultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				     ValueFPR (FR, fmt), fmt));
  }
#line 10693 "semantics.c"
  return nia;
  /* Extraction: NMSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 10705 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWXC1_COP1X
#undef SWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SWXC1_COP1X
#undef MY_NAME
#define MY_NAME "SWXC1_COP1X"

  /* Extraction: SWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10734 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5589 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 10772 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5597 "../.././sim/mips/mips.igen"

    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    {
     address_word vaddr = loadstore_ea (SD_, base, index);
     address_word paddr;
     int uncached;
     if ((vaddr & 3) != 0)
       {
         SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
       }
     else
     {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
      {
       unsigned64 memval = 0;
       unsigned64 memval1 = 0;
       unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
       address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
       address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
       unsigned int byte;
       paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
       byte = ((vaddr & mask) ^ bigendiancpu);
       memval = (((unsigned64)COP_SW(1,FS)) << (8 * byte));
        {
         StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
        }
      }
     }
    }
  }
#line 10831 "semantics.c"
  return nia;
  /* Extraction: SWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#undef INDEX
#undef FS
#undef SFRAME
#line 10841 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREFX_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREFX_COP1X
#undef PREFX_COP1X
#undef MY_PREFIX
#define MY_PREFIX PREFX_COP1X
#undef MY_NAME
#define MY_NAME "PREFX_COP1X"

  /* Extraction: PREFX
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 10868 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5294 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "prefx %ld, r%ld(r%ld)", \
                    (long) HINT, \
                    (long) INDEX, \
                    (long) BASE);
#line 10892 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREFX_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5302 "../.././sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    {
      address_word vaddr = loadstore_ea (SD_, base, index);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        Prefetch(uncached,paddr,vaddr,isDATA,HINT);
    }
  }
#line 10928 "semantics.c"
  return nia;
  /* Extraction: PREFX
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#undef INDEX
#undef HINT
#line 10937 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWXC1_COP1X
#undef LWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX LWXC1_COP1X
#undef MY_NAME
#define MY_NAME "LWXC1_COP1X"

  /* Extraction: LWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 10964 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000f800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4956 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwxc1 f%ld, r%ld(r%ld)", \
                    (long) FD, \
                    (long) INDEX, \
                    (long) BASE);
#line 11002 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4964 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    COP_LW (1, FD, do_load (SD_, AccessLength_WORD, GPR[BASE], GPR[INDEX]));
  }
#line 11032 "semantics.c"
  return nia;
  /* Extraction: LWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#undef INDEX
#undef FD
#line 11041 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQL_NORMAL
#undef BEQL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQL_NORMAL
#undef MY_NAME
#define MY_NAME "BEQL_NORMAL"

  /* Extraction: BEQL
       #define do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11068 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x14,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 695 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beql r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 11087 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 708 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 11121 "semantics.c"
  return nia;
  /* Extraction: BEQL
       #undef do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 11130 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNEL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNEL_NORMAL
#undef BNEL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNEL_NORMAL
#undef MY_NAME
#define MY_NAME "BNEL_NORMAL"

  /* Extraction: BNEL
       #define do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11157 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x15,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1060 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bnel r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 11176 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNEL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1073 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 11210 "semantics.c"
  return nia;
  /* Extraction: BNEL
       #undef do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 11219 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZL_NORMAL
#undef BLEZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZL_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZL_NORMAL"

  /* Extraction: BLEZL
       #define do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11244 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x16,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 903 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 11267 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 916 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 11301 "semantics.c"
  return nia;
  /* Extraction: BLEZL
       #undef do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 11309 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZL_NORMAL
#undef BGTZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZL_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZL_NORMAL"

  /* Extraction: BGTZL
       #define do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11334 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x17,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 850 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 11357 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 863 "../.././sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 11393 "semantics.c"
  return nia;
  /* Extraction: BGTZL
       #undef do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 11401 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LB_NORMAL
#undef LB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LB_NORMAL
#undef MY_NAME
#define MY_NAME "LB_NORMAL"

  /* Extraction: LB
       #define do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11428 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x20,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2097 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11447 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2111 "../.././sim/mips/mips.igen"
    GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11475 "semantics.c"
  return nia;
  /* Extraction: LB
       #undef do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11484 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LH_NORMAL
#undef LH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LH_NORMAL
#undef MY_NAME
#define MY_NAME "LH_NORMAL"

  /* Extraction: LH
       #define do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11511 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x21,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2200 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11530 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2214 "../.././sim/mips/mips.igen"
    GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11558 "semantics.c"
  return nia;
  /* Extraction: LH
       #undef do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11567 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWL_NORMAL
#undef LWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWL_NORMAL
#undef MY_NAME
#define MY_NAME "LWL_NORMAL"

  /* Extraction: LWL
       #define do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11594 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x22,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2378 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11613 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2392 "../.././sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 11641 "semantics.c"
  return nia;
  /* Extraction: LWL
       #undef do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11650 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LW_NORMAL
#undef LW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LW_NORMAL
#undef MY_NAME
#define MY_NAME "LW_NORMAL"

  /* Extraction: LW
       #define do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11677 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x23,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2340 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11696 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2354 "../.././sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11724 "semantics.c"
  return nia;
  /* Extraction: LW
       #undef do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11733 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LBU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LBU_NORMAL
#undef LBU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LBU_NORMAL
#undef MY_NAME
#define MY_NAME "LBU_NORMAL"

  /* Extraction: LBU
       #define do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11760 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x24,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2116 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lbu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11779 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LBU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2130 "../.././sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 11807 "semantics.c"
  return nia;
  /* Extraction: LBU
       #undef do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11816 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LHU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LHU_NORMAL
#undef LHU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LHU_NORMAL
#undef MY_NAME
#define MY_NAME "LHU_NORMAL"

  /* Extraction: LHU
       #define do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11843 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x25,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2219 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lhu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11862 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LHU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2233 "../.././sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 11890 "semantics.c"
  return nia;
  /* Extraction: LHU
       #undef do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11899 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWR_NORMAL
#undef LWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWR_NORMAL
#undef MY_NAME
#define MY_NAME "LWR_NORMAL"

  /* Extraction: LWR
       #define do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11926 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x26,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2397 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11945 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2411 "../.././sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 11973 "semantics.c"
  return nia;
  /* Extraction: LWR
       #undef do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11982 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SB_NORMAL
#undef SB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SB_NORMAL
#undef MY_NAME
#define MY_NAME "SB_NORMAL"

  /* Extraction: SB
       #define do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12009 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x28,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3154 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12028 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3168 "../.././sim/mips/mips.igen"
    do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12056 "semantics.c"
  return nia;
  /* Extraction: SB
       #undef do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12065 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SH_NORMAL
#undef SH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SH_NORMAL
#undef MY_NAME
#define MY_NAME "SH_NORMAL"

  /* Extraction: SH
       #define do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12092 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x29,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3323 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12111 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3337 "../.././sim/mips/mips.igen"
    do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12139 "semantics.c"
  return nia;
  /* Extraction: SH
       #undef do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12148 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWL_NORMAL
#undef SWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWL_NORMAL
#undef MY_NAME
#define MY_NAME "SWL_NORMAL"

  /* Extraction: SWL
       #define do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12175 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3730 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12194 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3744 "../.././sim/mips/mips.igen"
    do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12222 "semantics.c"
  return nia;
  /* Extraction: SWL
       #undef do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12231 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SW_NORMAL
#undef SW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SW_NORMAL
#undef MY_NAME
#define MY_NAME "SW_NORMAL"

  /* Extraction: SW
       #define do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12258 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3692 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12277 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3706 "../.././sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12305 "semantics.c"
  return nia;
  /* Extraction: SW
       #undef do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12314 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWR_NORMAL
#undef SWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWR_NORMAL
#undef MY_NAME
#define MY_NAME "SWR_NORMAL"

  /* Extraction: SWR
       #define do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12341 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2e,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3749 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12360 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3763 "../.././sim/mips/mips.igen"
    do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12388 "semantics.c"
  return nia;
  /* Extraction: SWR
       #undef do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12397 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CACHE_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CACHE_NORMAL
#undef CACHE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX CACHE_NORMAL
#undef MY_NAME
#define MY_NAME "CACHE_NORMAL"

  /* Extraction: CACHE
       #define do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12424 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2f,5.BASE,5.OP,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5747 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cache %ld, %ld(r%ld)", \
                    (long) OP, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12443 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CACHE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5759 "../.././sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        CacheOp(OP,vaddr,paddr,instruction_0);
    }
  }
#line 12479 "semantics.c"
  return nia;
  /* Extraction: CACHE
       #undef do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#undef OP
#undef OFFSET
#line 12488 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWCz_NORMAL
#undef LWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWCz_NORMAL
#undef MY_NAME
#define MY_NAME "LWCz_NORMAL"

  /* Extraction: LWCz
       #define do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12517 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2359 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12537 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2373 "../.././sim/mips/mips.igen"
    COP_LW (ZZ, RT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 12565 "semantics.c"
  return nia;
  /* Extraction: LWCz
       #undef do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 12575 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LL_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LL_NORMAL
#undef LL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LL_NORMAL
#undef MY_NAME
#define MY_NAME "LL_NORMAL"

  /* Extraction: LL
       #define do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12602 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x30,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2238 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ll r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12621 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2250 "../.././sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
          SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    unsigned int shift = 2;
    	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
    	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
    	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
    	    byte = ((vaddr & mask) ^ (bigend << shift));
    	    GPR[RT] = EXTEND32 (memval >> (8 * byte));
    	    LLBIT = 1;
    	  }
        }
    }
  }
#line 12677 "semantics.c"
  return nia;
  /* Extraction: LL
       #undef do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 12686 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWC1_COP1
#undef LWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX LWC1_COP1
#undef MY_NAME
#define MY_NAME "LWC1_COP1"

  /* Extraction: LWC1
       #define do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12713 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x31,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4936 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12746 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4950 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LW (1, FT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 12775 "semantics.c"
  return nia;
  /* Extraction: LWC1
       #undef do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12784 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREF_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREF_NORMAL
#undef PREF_NORMAL
#undef MY_PREFIX
#define MY_PREFIX PREF_NORMAL
#undef MY_NAME
#define MY_NAME "PREF_NORMAL"

  /* Extraction: PREF
       #define do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12811 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x33,5.BASE,5.HINT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3006 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "pref %ld, %ld(r%ld)", \
                    (long) HINT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12830 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREF_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3015 "../.././sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      {
        if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	Prefetch(uncached,paddr,vaddr,isDATA,HINT);
      }
    }
  }
#line 12868 "semantics.c"
  return nia;
  /* Extraction: PREF
       #undef do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#undef HINT
#undef OFFSET
#line 12877 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDC1b_COP1
#undef LDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX LDC1b_COP1
#undef MY_NAME
#define MY_NAME "LDC1b_COP1"

  /* Extraction: LDC1b
       #define do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12904 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x35,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4860 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12937 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4870 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 12966 "semantics.c"
  return nia;
  /* Extraction: LDC1b
       #undef do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12975 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWCz_NORMAL
#undef SWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWCz_NORMAL
#undef MY_NAME
#define MY_NAME "SWCz_NORMAL"

  /* Extraction: SWCz
       #define do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13004 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3711 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13024 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3725 "../.././sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
  }
#line 13052 "semantics.c"
  return nia;
  /* Extraction: SWCz
       #undef do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 13062 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SC_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SC_NORMAL
#undef SC_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SC_NORMAL
#undef MY_NAME
#define MY_NAME "SC_NORMAL"

  /* Extraction: SC
       #define do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13089 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x38,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3173 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sc r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13108 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SC_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3185 "../.././sim/mips/mips.igen"
    unsigned32 instruction = instruction_0;
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
    	    address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = ((unsigned64) GPR[RT] << (8 * byte));
    	    if (LLBIT)
    	      {
    		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	      }
    	    GPR[RT] = LLBIT;
    	  }
        }
    }
  }
#line 13167 "semantics.c"
  return nia;
  /* Extraction: SC
       #undef do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 13176 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWC1_COP1
#undef SWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX SWC1_COP1
#undef MY_NAME
#define MY_NAME "SWC1_COP1"

  /* Extraction: SWC1
       #define do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13203 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x39,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5543 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13236 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5557 "../.././sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_fpu (SD_);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    uword64 memval = 0;
    	    uword64 memval1 = 0;
    	    uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ?(mask ^ AccessLength_WORD): 0);
    	    address_word bigendiancpu = (BigEndianCPU ?(mask ^ AccessLength_WORD): 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = (((uword64)COP_SW(((instruction_0 >> 26) & 0x3),FT)) << (8 * byte));
    	    StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	  }
        }
    }
  }
#line 13291 "semantics.c"
  return nia;
  /* Extraction: SWC1
       #undef do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 13300 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDC1b_COP1
#undef SDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX SDC1b_COP1
#undef MY_NAME
#define MY_NAME "SDC1b_COP1"

  /* Extraction: SDC1b
       #define do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13327 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3d,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5424 "../.././sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13360 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5434 "../.././sim/mips/mips.igen"
    check_fpu (SD_);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
  }
#line 13389 "semantics.c"
  return nia;
  /* Extraction: SDC1b
       #undef do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 13398 "semantics.c"
}

#endif /* _SEMANTICS_C_*/
