/* This file is part of GDB.

   Copyright 2002, 2007 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   --

   This file was generated by the program igen */

#ifndef SUPPORT_C
#define SUPPORT_C

#include "sim-main.h"
#include "idecode.h"
#include "itable.h"
#include "support.h"

INLINE_SUPPORT\
(instruction_address)
semantic_illegal
(SIM_DESC sd,
 instruction_address cia)
{
#line 88 "../.././sim/mips/mips.igen"
  SignalException (ReservedInstruction, 0);
  sim_engine_abort (SD, CPU, cia, "Internal function must longjump\n");
  return cia;
}
#line 42 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word target)
{
#line 109 "../.././sim/mips/mips.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = CIA + 4; /* NOTE not mips16 */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM32 (CIA); /* NOTE not mips16 */
  ENGINE_ISSUE_PREFIX_HOOK();
  idecode_issue (CPU_, delay_insn, (CIA));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 61 "support.c"

INLINE_SUPPORT\
(address_word)
nullify_next_insn32
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 123 "../.././sim/mips/mips.igen"
  sim_events_slip (SD, 1);
  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
  return CIA + 8;
}
#line 73 "support.c"

INLINE_SUPPORT\
(address_word)
loadstore_ea
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word base, address_word offset)
{
#line 146 "../.././sim/mips/mips.igen"
  return base + offset;
}
#line 83 "support.c"

INLINE_SUPPORT\
(int)
not_word_value
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned_word value)
{
#line 185 "../.././sim/mips/mips.igen"
#if WITH_TARGET_WORD_BITSIZE == 64
  return value != (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);
#else
  return 0;
#endif
}
#line 97 "support.c"

INLINE_SUPPORT\
(void)
unpredictable
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 210 "../.././sim/mips/mips.igen"
}
#line 106 "support.c"

INLINE_SUPPORT\
(int)
check_mf_cycles
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, signed64 time, const char *new)
{
#line 259 "../.././sim/mips/mips.igen"
  if (history->mf.timestamp + 3 > time)
    {
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: %s at 0x%08lx too close to MF at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			new, (long) CIA,
  			(long) history->mf.cia);
      return 0;
    }
  return 1;
}
#line 124 "support.c"

INLINE_SUPPORT\
(int)
check_mt_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history)
{
#line 294 "../.././sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)
  	    || check_mf_cycles (SD_, history, time, "MT"));
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}
#line 139 "support.c"

INLINE_SUPPORT\
(int)
check_mf_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, hilo_history *peer)
{
#line 335 "../.././sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = 1;
  if (peer != NULL
      && peer->mt.timestamp > history->op.timestamp
      && history->mt.timestamp < history->op.timestamp
      && ! (history->mf.timestamp > history->op.timestamp
  	    && history->mf.timestamp < peer->mt.timestamp)
      && ! (peer->mf.timestamp > history->op.timestamp
  	    && peer->mf.timestamp < peer->mt.timestamp))
    {
      /* The peer has been written to since the last OP yet we have
         not */
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: MF at 0x%08lx following OP at 0x%08lx corrupted by MT at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			(long) CIA,
  			(long) history->op.cia,
  			(long) peer->mt.cia);
      ok = 0;
    }
  history->mf.timestamp = time;
  history->mf.cia = CIA;
  return ok;
}
#line 170 "support.c"

INLINE_SUPPORT\
(int)
check_mult_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 387 "../.././sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 188 "support.c"

INLINE_SUPPORT\
(int)
check_div_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 442 "../.././sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 206 "support.c"

INLINE_SUPPORT\
(void)
check_u64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, instruction_word insn)
{
#line 483 "../.././sim/mips/mips.igen"
  // The check should be similar to mips64 for any with PX/UX bit equivalents.
}
#line 216 "support.c"

INLINE_SUPPORT\
(void)
do_addiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 565 "../.././sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = EXTEND32 (GPR[rs] + EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 230 "support.c"

INLINE_SUPPORT\
(void)
do_addu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 594 "../.././sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] + GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 244 "support.c"

INLINE_SUPPORT\
(void)
do_and
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 623 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] & GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 256 "support.c"

INLINE_SUPPORT\
(void)
do_daddiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 1227 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = GPR[rs] + EXTEND16 (immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 268 "support.c"

INLINE_SUPPORT\
(void)
do_daddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1250 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] + GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 280 "support.c"

INLINE_SUPPORT\
(void)
do_ddiv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1323 "../.././sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed64 n = GPR[rs];
    signed64 d = GPR[rt];
    signed64 hi;
    signed64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 315 "support.c"

INLINE_SUPPORT\
(void)
do_ddivu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1369 "../.././sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned64 n = GPR[rs];
    unsigned64 d = GPR[rt];
    unsigned64 hi;
    unsigned64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 345 "support.c"

INLINE_SUPPORT\
(void)
do_div
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1408 "../.././sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed32 n = GPR[rs];
    signed32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else if (n == SIGNED32 (0x80000000) && d == -1)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 376 "support.c"

INLINE_SUPPORT\
(void)
do_divu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1454 "../.././sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned32 n = GPR[rs];
    unsigned32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 402 "support.c"

INLINE_SUPPORT\
(void)
do_dmultx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd, int signed_p)
{
#line 1494 "../.././sim/mips/mips.igen"
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  /* make signed multiply unsigned */
  sign = 0;
  if (signed_p)
    {
      if ((signed64) op1 < 0)
  	{
  	  op1 = - op1;
  	  ++sign;
  	}
      if ((signed64) op2 < 0)
  	{
  	  op2 = - op2;
  	  ++sign;
  	}
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
  	 + (unsigned64) VL4_8 (m10)
  	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
  	+ (unsigned64) VH4_8 (mid)
  	+ (unsigned64) VH4_8 (m01)
  	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
  	hi = -hi;
      else
  	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 467 "support.c"

INLINE_SUPPORT\
(void)
do_dmult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1554 "../.././sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 1);
}
#line 477 "support.c"

INLINE_SUPPORT\
(void)
do_dmultu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1583 "../.././sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 0);
}
#line 487 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_dror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned64 x,unsigned64 y)
{
#line 1611 "../.././sim/mips/mips.igen"
  unsigned64 result;

  y &= 63;
  TRACE_ALU_INPUT2 (x, y);
  result = ROTR64 (x, y);
  TRACE_ALU_RESULT (result);
  return result;
}
#line 503 "support.c"

INLINE_SUPPORT\
(void)
do_dsll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1653 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = GPR[rt] << shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 515 "support.c"

INLINE_SUPPORT\
(void)
do_dsllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1692 "../.././sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 528 "support.c"

INLINE_SUPPORT\
(void)
do_dsra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1714 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = ((signed64) GPR[rt]) >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 540 "support.c"

INLINE_SUPPORT\
(void)
do_dsrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1755 "../.././sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 553 "support.c"

INLINE_SUPPORT\
(void)
do_dsrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1777 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = (unsigned64) GPR[rt] >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 565 "support.c"

INLINE_SUPPORT\
(void)
do_dsrlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1818 "../.././sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 578 "support.c"

INLINE_SUPPORT\
(void)
do_dsubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1864 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] - GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 590 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset)
{
#line 1988 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isDATA, isREAL);
  byte = ((vaddr & mask) ^ bigendiancpu);
  return (memval >> (8 * byte));
}
#line 618 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2011 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, uncached, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR_31..32-NR_LHS_BITS_ = memval_NR_LHS_BITS-1..0_ */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR_31..32-NR_LHS_BITS = memval_32+NR_LHS_BITS..32_ */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) memval >> 32), (long) memval,
  	   (long) ((unsigned64) temp >> 32), (long) temp,
  	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
  	   (long) (rt >> 32), (long) rt); */
  return rt;
}
#line 679 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2067 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, uncached, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}
#line 714 "support.c"

INLINE_SUPPORT\
(void)
do_mfhi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2518 "../.././sim/mips/mips.igen"
  check_mf_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT1 (HI);
  GPR[rd] = HI;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 727 "support.c"

INLINE_SUPPORT\
(void)
do_mflo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2557 "../.././sim/mips/mips.igen"
  check_mf_hilo (SD_, LOHISTORY, HIHISTORY);
  TRACE_ALU_INPUT1 (LO);
  GPR[rd] = LO;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 740 "support.c"

INLINE_SUPPORT\
(void)
do_mult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2798 "../.././sim/mips/mips.igen"
  signed64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  ACX = 0;  /* SmartMIPS */
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 762 "support.c"

INLINE_SUPPORT\
(void)
do_multu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2865 "../.././sim/mips/mips.igen"
  unsigned64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((unsigned64)(unsigned32) GPR[rs])
  	  * ((unsigned64)(unsigned32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 783 "support.c"

INLINE_SUPPORT\
(void)
do_nor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2928 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ~ (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 795 "support.c"

INLINE_SUPPORT\
(void)
do_or
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2954 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 807 "support.c"

INLINE_SUPPORT\
(void)
do_ori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned immediate)
{
#line 2981 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = (GPR[rs] | immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 819 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_ror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned32 x,unsigned32 y)
{
#line 3031 "../.././sim/mips/mips.igen"
  unsigned64 result;

  y &= 31;
  TRACE_ALU_INPUT2 (x, y);
  result = EXTEND32 (ROTR32 (x, y));
  TRACE_ALU_RESULT (result);
  return result;
}
#line 835 "support.c"

INLINE_SUPPORT\
(void)
do_store
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word word)
{
#line 3065 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  byte = ((vaddr & mask) ^ bigendiancpu);
  memval = (word << (8 * byte));
  StoreMemory (uncached, access, memval, 0, paddr, vaddr, isREAL);
}
#line 863 "support.c"

INLINE_SUPPORT\
(void)
do_store_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 3088 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) rt >> 32), (long) rt,
  	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (uncached, byte, memval, 0, paddr, vaddr, isREAL);
}
#line 913 "support.c"

INLINE_SUPPORT\
(void)
do_store_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 3133 "../.././sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (uncached, access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}
#line 939 "support.c"

INLINE_SUPPORT\
(void)
do_sll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3343 "../.././sim/mips/mips.igen"
  unsigned32 temp = (GPR[rt] << shift);
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 952 "support.c"

INLINE_SUPPORT\
(void)
do_sllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3385 "../.././sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (GPR[rt] << s);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 966 "support.c"

INLINE_SUPPORT\
(void)
do_slt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3413 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((signed_word) GPR[rs] < (signed_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 978 "support.c"

INLINE_SUPPORT\
(void)
do_slti
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3439 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 990 "support.c"

INLINE_SUPPORT\
(void)
do_sltiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3465 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1002 "support.c"

INLINE_SUPPORT\
(void)
do_sltu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3492 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1014 "support.c"

INLINE_SUPPORT\
(void)
do_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3518 "../.././sim/mips/mips.igen"
  signed32 temp = (signed32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1029 "support.c"

INLINE_SUPPORT\
(void)
do_srav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3548 "../.././sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  signed32 temp = (signed32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1045 "support.c"

INLINE_SUPPORT\
(void)
do_srl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3579 "../.././sim/mips/mips.igen"
  unsigned32 temp = (unsigned32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1060 "support.c"

INLINE_SUPPORT\
(void)
do_srlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3608 "../.././sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (unsigned32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1076 "support.c"

INLINE_SUPPORT\
(void)
do_subu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3665 "../.././sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] - GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1090 "support.c"

INLINE_SUPPORT\
(void)
do_xor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4023 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] ^ GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1102 "support.c"

INLINE_SUPPORT\
(void)
do_xori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 4049 "../.././sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] ^ immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1114 "support.c"

INLINE_SUPPORT\
(const char *)
str_FMT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt)
{
#line 4082 "../.././sim/mips/mips.igen"
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    case fmt_ps: return "ps";
    default: return "?";
    }
}
#line 1132 "support.c"

INLINE_SUPPORT\
(const char *)
str_TF
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf)
{
#line 4095 "../.././sim/mips/mips.igen"
  if (tf)
    return "t";
  else
    return "f";
}
#line 1145 "support.c"

INLINE_SUPPORT\
(const char *)
str_ND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int nd)
{
#line 4103 "../.././sim/mips/mips.igen"
  if (nd)
    return "l";
  else
    return "";
}
#line 1158 "support.c"

INLINE_SUPPORT\
(const char *)
str_COND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int cond)
{
#line 4111 "../.././sim/mips/mips.igen"
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}
#line 1187 "support.c"

INLINE_SUPPORT\
(void)
check_fmt_p
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, instruction_word insn)
{
#line 4151 "../.././sim/mips/mips.igen"
  /* None of these ISAs support Paired Single, so just fall back to
     the single/double check.  */
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}
#line 1200 "support.c"

INLINE_SUPPORT\
(void)
check_fpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 4195 "../.././sim/mips/mips.igen"
  if (! COP_Usable (1))
    SignalExceptionCoProcessorUnusable (1);
}
#line 1211 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot16
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word nia, address_word target)
{
#line 1037 "m16.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA; /* save current PC somewhere */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM16 (nia); /* NOTE: mips16 */
  idecode_issue (CPU_, delay_insn, (nia));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 1228 "support.c"

INLINE_SUPPORT\
(address_word)
basepc
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 1050 "m16.igen"
  if (STATE & simDELAYSLOT)
    {
      return DSPC; /* return saved address of preceeding jmp */
    }
  else
    {
      return CIA;
    }
}
#line 1245 "support.c"

INLINE_SUPPORT\
(void)
do_save
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int xsregs, int aregs, int ras0s1, int framesize)
{
#line 171 "m16e.igen"
  unsigned_word temp;    
  int args, astatic;

  temp = GPR[29];

  /* writes are in the same order as the hardware description... */
  switch (aregs) {
  case 0: case 1: case 2: case 3: case 11:
    args = 0;
    break;
  case 4: case 5: case 6: case 7:
    args = 1;
    break;
  case 8: case 9: case 10:
    args = 2;
    break;
  case 12: case 13:
    args = 3;
    break;
  case 14:
    args = 4;
    break;
  default:
    sim_engine_abort (SD, CPU, CIA, "save: aregs=%d causes unpredictable results\n", aregs);
  }
  if (args > 0) {
    do_store (SD_, AccessLength_WORD, temp, 0, GPR[4]); 
    if (args > 1) {
      do_store (SD_,AccessLength_WORD, temp, 4 , GPR[5]); 
      if (args > 2) {
  	do_store (SD_,AccessLength_WORD, temp, 8 , GPR[6]); 
  	if (args > 3) {
  	  do_store (SD_,AccessLength_WORD, temp, 12, GPR[7]);
  	}
      }
    }
  }

  if (ras0s1 & 4)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[31]); 

  switch (xsregs) {
  case 7:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[30]); 
  case 6:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[23]); 
  case 5:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[22]); 
  case 4:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[21]); 
  case 3:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[20]); 
  case 2:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[19]); 
  case 1:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[18]); 
  }

  if (ras0s1 & 1)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[17]); 
  if (ras0s1 & 2)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[16]); 

  switch (aregs) {
  case 0: case 4: case 8: case 12: case 14:
    astatic = 0;
    break;
  case 1: case 5: case 9: case 13:
    astatic = 1;
    break;
  case 2: case 6: case 10:
    astatic = 2;
    break;
  case 3: case 7:
    astatic = 3;
    break;
  case 11:
    astatic = 4;
    break;
  default:
    sim_engine_abort (SD, CPU, CIA, "save: aregs=%d causes unpredictable results\n", aregs);
  }
  if (astatic > 0) {
    do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[7]);
    if (astatic > 1) {
      do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[6]);
      if (astatic > 2) {
  	do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[5]);
  	if (astatic > 3) {
  	  do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[4]);
  	}
      }
    }
  }

  GPR[29] -= framesize;
}
#line 1350 "support.c"

INLINE_SUPPORT\
(const char *)
str_MFHI
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hi)
{
#line 8 "vr.igen"
  return hi ? "hi" : "";
}
#line 1360 "support.c"

INLINE_SUPPORT\
(const char *)
str_SAT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int s)
{
#line 13 "vr.igen"
  return s ? "s" : "";
}
#line 1370 "support.c"

INLINE_SUPPORT\
(const char *)
str_UNS
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int u)
{
#line 18 "vr.igen"
  return u ? "u" : "";
}
#line 1380 "support.c"

INLINE_SUPPORT\
(void)
do_vr_mul_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p)
{
#line 43 "vr.igen"
  unsigned64 lhs, x, y, xcut, ycut, product, result;

  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);

  lhs = (!accumulate_p ? 0 : double_p ? LO : U8_4 (HI, LO));
  x = GPR[rs];
  y = GPR[rt];

  /* Work out the canonical form of X and Y from their significant bits.  */
  if (!short_p)
    {
      /* Normal sign-extension rule for 32-bit operands.  */
      xcut = EXTEND32 (x);
      ycut = EXTEND32 (y);
    }
  else if (unsigned_p)
    {
      /* Operands must be zero-extended 16-bit numbers.  */
      xcut = x & 0xffff;
      ycut = y & 0xffff;
    }
  else
    {
      /* Likewise but sign-extended.  */
      xcut = EXTEND16 (x);
      ycut = EXTEND16 (y);
    }
  if (x != xcut || y != ycut)
    sim_engine_abort (SD, CPU, CIA,
  		      "invalid multiplication operand at 0x%08lx\n",
  		      (long) CIA);

  TRACE_ALU_INPUT2 (x, y);
  product = (unsigned_p
  	     ? V8_4 (x, 1) * V8_4 (y, 1)
  	     : EXTEND32 (x) * EXTEND32 (y));
  result = (subtract_p ? lhs - product : lhs + product);
  if (saturate_p)
    {
      /* Saturate the result to 32 bits.  An unsigned, unsaturated
  	 result is zero-extended to 64 bits, but unsigned overflow
  	 causes all 64 bits to be set.  */
      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)
  	result = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);
      else if (unsigned_p && (result >> 32) != 0)
  	result = (unsigned64) 0 - 1;
    }
  TRACE_ALU_RESULT (result);

  if (double_p)
    LO = result;
  else
    {
      LO = EXTEND32 (result);
      HI = EXTEND32 (VH4_8 (result));
    }
  if (rd != 0)
    GPR[rd] = store_hi_p ? HI : LO;
}
#line 1447 "support.c"

INLINE_SUPPORT\
(void)
do_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 27 "dsp.igen"
  int i;
  signed32 h0 = 0;
  signed16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (signed32)h1 + (signed32)h2;
      else if (op == 1) // SUB
        h0 = (signed32)h1 - (signed32)h2;
      else // MUL
        h0 = (signed32)h1 * (signed32)h2;
      if (h0 > (signed32)0x7fff || h0 < (signed32)0xffff8000)
  	{
  	  if (op == 0 || op == 1) // ADD, SUB
  	    DSPCR |= DSPCR_OUFLAG4;
  	  else if (op == 2) // MUL
  	    DSPCR |= DSPCR_OUFLAG5;
  	  if (sat == 1)
  	    {
  	      if (h0 > (signed32)0x7fff)
  		h0 = 0x7fff;
  	      else
  		h0 = 0x8000;
  	    }
  	}
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1489 "support.c"

INLINE_SUPPORT\
(void)
do_w_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 65 "dsp.igen"
  signed64 h0;
  signed32 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  h1 = (signed32)v1;
  h2 = (signed32)v2;
  if (op == 0) // ADD
    h0 = (signed64)h1 + (signed64)h2;
  else // SUB
    h0 = (signed64)h1 - (signed64)h2;
  if (((h0 & 0x100000000LL) >> 1) != (h0 & 0x80000000))
    {
      DSPCR |= DSPCR_OUFLAG4;
      if (h0 & 0x100000000LL)
  	h0 = 0x80000000;
      else
  	h0 = 0x7fffffff;
    }
  GPR[rd] = EXTEND32 (h0);
}
#line 1518 "support.c"

INLINE_SUPPORT\
(void)
do_qb_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 91 "dsp.igen"
  int i;
  unsigned32 h0;
  unsigned8 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (h0 & 0x100)
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    {
  	      if (op == 0) // ADD
  		h0 = 0xff;
  	      else // SUB
  		h0 = 0;
  	    }
  	}
      result |= ((unsigned32)((unsigned8)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1555 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op)
{
#line 124 "dsp.igen"
  int i, j;
  unsigned8 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      h0 = (unsigned8)(v1 & 0xff);
      if (op == 0) // left
  	{
  	  for (j = 7; j >= 8 - shift; j--)
  	    {
  	      if (h0 & (1<<j))
  		{
  		  DSPCR |= DSPCR_OUFLAG6;
  		  break;
  		}
  	    }
          h0 = h0 << shift;
  	}
      else // right
        h0 = h0 >> shift;
      result |= ((unsigned32)h0 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1588 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op, int sat)
{
#line 154 "dsp.igen"
  int i, j;
  signed16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (signed16)(v1 & 0xffff);
      if (op == 0) // left
  	{
  	  setcond = 0;
  	  if (h0 & (1<<15))
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (!(h0 & (1 << j)))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 1;
  		      break;
  		    }
  		}
  	    }
  	  else
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (h0 & (1 << j))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 2;
  		      break;
  		    }
  		}
  	    }
  	  h0 = h0 << shift;
  	  if (sat == 1)
  	    {
  	      if (setcond == 2)
  		h0 = 0x7fff; 
  	      else if (setcond == 1)
  		h0 = 0x8000;
  	    }
  	}
      else // right
  	{
  	  if (sat == 1 && shift != 0 && (h0 & (1 << (shift-1))))
  	    h0 = (h0 >> shift) + 1;
  	  else
  	    h0 = h0 >> shift;
  	}

      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1652 "support.c"

INLINE_SUPPORT\
(void)
do_w_shll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 213 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond = 0;
  if (v1 & (1 << 31))
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (!(v1 & (1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 1;
  	      break;
  	    }
  	}
    }
  else
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (v1 & (1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (setcond == 2)
    result = 0x7fffffff; 
  else if (setcond == 1)
    result = 0x80000000;
  else
    result = v1 << shift; 
  GPR[rd] = EXTEND32 (result);
}
#line 1696 "support.c"

INLINE_SUPPORT\
(void)
do_w_shra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 252 "dsp.igen"
  unsigned32 result = GPR[rt];
  signed32 h0 = (signed32)result;
  if (shift != 0 && (h0 & (1 << (shift-1))))
    h0 = (h0 >> shift) + 1;
  else
    h0 = h0 >> shift;
  GPR[rd] = EXTEND32 (h0);
}
#line 1712 "support.c"

INLINE_SUPPORT\
(void)
do_qb_muleu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 745 "dsp.igen"
  int i;
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned16 h1, h2;
  unsigned32 prod;
  if (loc == 0)
    v1 >>= 16;
  for (i = 0; i < 32; i += 16, v1 >>= 8, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xff);
      h2 = (unsigned16)(v2 & 0xffff);
      prod = (unsigned32)h1 * (unsigned32)h2;
      if (prod > 0xffff)
  	{
  	  DSPCR |= DSPCR_OUFLAG5;
  	  prod = 0xffff;
  	}
      result |= ((unsigned32)prod << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1742 "support.c"

INLINE_SUPPORT\
(void)
do_ph_mulq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int round)
{
#line 785 "dsp.igen"
  int i;
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 prod;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= DSPCR_OUFLAG5;
  	  prod = 0x7fffffff;
  	}
      else
  	{
  	  prod = ((signed32)h1 * (signed32)h2) << 1;
  	  if (round == 1)
  	    prod += (signed32)0x8000;
  	}
      result |= (((unsigned32)prod >> 16) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 1775 "support.c"

INLINE_SUPPORT\
(void)
do_ph_muleq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 821 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 prod;
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= DSPCR_OUFLAG5;
      prod = 0x7fffffff;
    }
  else
    prod = ((signed32)h1 * (signed32)h2) << 1;
  GPR[rd] = EXTEND32 (prod);
}
#line 1806 "support.c"

INLINE_SUPPORT\
(void)
do_qb_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 863 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (loc == 0)
    {
      v1 >>= 16;
      v2 >>= 16;
    }
  for (i = 0; i < 16; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // DPAU
  	prod += (unsigned64)h1 * (unsigned64)h2;
      else // DPSU
  	prod -= (unsigned64)h1 * (unsigned64)h2;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 1838 "support.c"

INLINE_SUPPORT\
(void)
do_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 919 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = (signed32)0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;

      if (op == 0) // DPAQ
  	prod += (signed64)result;
      else // DPSQ
  	prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 1874 "support.c"

INLINE_SUPPORT\
(void)
do_w_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 998 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 h1, h2;
  signed64 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned32 resultlo;
  unsigned32 resulthi;
  unsigned32 carry;
  unsigned64 temp1;
  signed64 temp2;
  h1 = (signed32) v1;
  h2 = (signed32) v2;
  if (h1 == 0x80000000 && h2 == 0x80000000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed64) 0x7fffffffffffffffLL;
    }
  else
    result = ((signed64)h1 * (signed64)h2) << 1;
  resultlo = (unsigned32)(result);
  resulthi = (unsigned32)(result >> 32);
  if (op ==0) // DPAQ
    {
      temp1 = (unsigned64)lo + (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) + (signed64)((signed32)resulthi) +
  	      (signed64)((signed32)carry);
    }
  else // DPSQ
    {
      temp1 = (unsigned64)lo - (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) - (signed64)((signed32)resulthi) -
  	      (signed64)((signed32)carry);
    }
  if (((temp2 & 0x100000000LL) >> 1) != (temp2 & 0x80000000LL))
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      if (temp2 & 0x100000000LL)
  	{
  	  DSPLO(ac) = EXTEND32 (0x00000000);
  	  DSPHI(ac) = EXTEND32 (0x80000000);
  	}
      else
  	{
  	  DSPLO(ac) = EXTEND32 (0xffffffff);
  	  DSPHI(ac) = EXTEND32 (0x7fffffff);
  	}
    }
  else
    {
      DSPLO(ac) = EXTEND32 (temp1);
      DSPHI(ac) = EXTEND32 (temp2);
    }
}
#line 1938 "support.c"

INLINE_SUPPORT\
(void)
do_ph_maq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 1073 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed32)0x7fffffff;
    }
  else
    result = ((signed32)h1 * (signed32)h2) << 1;
  prod += (signed64)result;
  if (op == 1) // MAQ_SA
    {
      if (prod & 0x8000000000000000LL)
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (!(prod & ((signed64)1 << i)))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0xffffffff80000000LL;
  		  break;
  		}
  	    }
  	}
      else
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (prod & ((signed64)1 << i))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0x7fffffff;
  		  break;
  		}
  	    }
  	}
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2002 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1233 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 2029 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpgu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 1277 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // EQ
  	result |= ((h1 == h2) << j);
      else if (op == 1) // LT
  	result |= ((h1 < h2) << j);
      else // LE
  	result |= ((h1 <= h2) << j);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2055 "support.c"

INLINE_SUPPORT\
(void)
do_ph_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1320 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 2082 "support.c"

INLINE_SUPPORT\
(void)
do_w_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift, int op)
{
#line 1415 "dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  int setcond = 0;
  if (!(prod & 0x8000000000000000LL))
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (prod & ((unsigned64)1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 1;
  	      break;
  	    }
  	}
      if (((prod >> (shift - 1)) & 0xffffffffLL) == 0xffffffffLL)
  	{
  	  DSPCR |= DSPCR_OUFLAG7;
  	  setcond = 1;
  	}
    }
  else
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (!(prod & ((unsigned64)1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (op == 0) // EXTR
    result = result >> shift;
  else if (op == 1) // EXTR_R
    {
      if (shift != 0)
        result = ((result >> (shift - 1)) + 1) >> 1;
      else
  	result = result >> shift;
    }
  else // EXTR_RS
    {
      if (setcond == 1)
  	result = 0x7fffffff;
      else if (setcond == 2)
  	result = 0x80000000;
      else 
  	{
  	  if (shift != 0)
  	    result = ((result >> (shift - 1)) + 1) >> 1;
  	  else
  	    result = result >> shift;
  	}
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2150 "support.c"

INLINE_SUPPORT\
(void)
do_h_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift)
{
#line 1523 "dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  signed64 value = 0xffffffffffff8000LL;
  result >>= shift;
  if (result > 0x7fff)
    {
      result = 0x7fff;
      DSPCR |= DSPCR_OUFLAG7;
    }
  else if (result < value)
    {
      result = value;
      DSPCR |= DSPCR_OUFLAG7;
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2177 "support.c"

INLINE_SUPPORT\
(void)
do_extp
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int size, int op)
{
#line 1561 "dsp.igen"
  signed32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  unsigned64 result = 0;
  if (pos - (size + 1) >= -1)
    {
      prod >>= (pos - size);
      result = prod & (((unsigned64)1 << (size + 1)) - 1);
      DSPCR &= (~DSPCR_EFI_SMASK);
      if (op == 1) // EXTPDP
  	{
  	  if (pos - (size + 1) >= 0)
  	    {
  	      DSPCR &= (~DSPCR_POS_SMASK);
  	      DSPCR |= ((pos - (size + 1)) & DSPCR_POS_MASK) << DSPCR_POS_SHIFT;
  	    }
  	  else if (pos - (size + 1) == -1)
  	    {
  	      DSPCR |= DSPCR_POS_SMASK;
  	    }
  	}
    }
  else
    {
      DSPCR |= DSPCR_EFI;
      Unpredictable ();
    }
  GPR[rt] = EXTEND32 (result);
}
#line 2215 "support.c"

INLINE_SUPPORT\
(void)
do_shilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int shift)
{
#line 1624 "dsp.igen"
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (shift > 31)
    shift = shift - 64;
  if (shift >= 0)
    prod >>= shift;
  else
    prod <<= (-shift);
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2235 "support.c"

INLINE_SUPPORT\
(void)
do_u_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 28 "dsp2.igen"
  int i;
  unsigned32 h0;
  unsigned16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xffff);
      h2 = (unsigned16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (op == 0 && (h0 > (unsigned32)0x0000ffff)) // ADD SAT
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    h0 = 0xffff;
  	}
      else if (op == 1 && h1 < h2) // SUB SAT
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    h0 = 0x0;
  	}
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2273 "support.c"

INLINE_SUPPORT\
(void)
do_uh_qb_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 63 "dsp2.igen"
  int i;
  unsigned32 h0;
  unsigned8 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (round == 1)
  	h0 = (h0 + 1) >> 1;
      else
  	h0 = h0 >> 1;
      result |= ((unsigned32)((unsigned8)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2303 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpgdu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 89 "dsp2.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	{
  	  result |= ((h1 == h2) << j);
  	  DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
  	}
      else if (op == 1) // LT
  	{
  	  result |= ((h1 < h2) << j);
  	  DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
  	}
      else // LE
  	{
  	  result |= ((h1 <= h2) << j);
  	  DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
  	}
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2341 "support.c"

INLINE_SUPPORT\
(void)
do_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 123 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      result = (signed32)h1 * (signed32)h2;
      if (op == 0) // DPA
        prod += (signed64)result;
      else // DPS
        prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2370 "support.c"

INLINE_SUPPORT\
(void)
do_w_mulq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int round)
{
#line 148 "dsp2.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 w1, w2;
  signed64 prod;
  unsigned32 result;
  w1 = (signed32) v1;
  w2 = (signed32 )v2;
  if (w1 == (signed32) 0x80000000 && w2 == (signed32) 0x80000000)
    {
      DSPCR |= DSPCR_OUFLAG5;
      prod = 0x7fffffff;
    }
  else
    {
      prod = ((signed64) w1 * (signed64) w2) << 1;
      if (round == 1)
  	prod += 0x0000000080000000LL;
      prod = prod >> 32;
    }
  result = (unsigned32) prod;
  GPR[rd] = EXTEND32 (result);
}
#line 2400 "support.c"

INLINE_SUPPORT\
(void)
do_precr_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int sa, int round)
{
#line 174 "dsp2.igen"
  unsigned32 v1 = GPR[rt];
  unsigned32 v2 = GPR[rs];
  signed32 w1 = (signed32) v1;
  signed32 w2 = (signed32) v2;
  signed32 result;
  if (sa != 0)
    {
      if (round == 1 && (w1 & (1 << (sa - 1))))
  	w1 = (w1 >> sa) + 1;
      else
  	w1 = w1 >> sa;

      if (round == 1 && (w2 & (1 << (sa - 1))))
  	w2 = (w2 >> sa) + 1;
      else
  	w2 = w2 >> sa;
    }
  result = (w1 << 16) | (w2 & 0xffff);
  GPR[rt] = EXTEND32 (result);
}
#line 2428 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int round)
{
#line 198 "dsp2.igen"
  int i, j;
  signed8 q0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      q0 = (signed8)(v1 & 0xff);
      if (shift != 0)
   	{
  	  if (round == 1 && (q0 & (1 << (shift - 1))))
  	    q0 = (q0 >> shift) + 1;
  	  else
  	    q0 = q0 >> shift;
   	}
      result |= ((unsigned32)((unsigned8)q0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2454 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 219 "dsp2.igen"
  int i, j;
  unsigned16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (unsigned16)(v1 & 0xffff);
      h0 = h0 >> shift;
      result |= ((unsigned32)h0 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2474 "support.c"

INLINE_SUPPORT\
(void)
do_qh_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 236 "dsp2.igen"
  int i;
  signed32 h0;
  signed16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (signed32)h1 + (signed32)h2;
      else // SUB
  	h0 = (signed32)h1 - (signed32)h2;
      if (round == 1)
  	h0 = (h0 + 1) >> 1;
      else
  	h0 = h0 >> 1;
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 2504 "support.c"

INLINE_SUPPORT\
(void)
do_qh_w_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 263 "dsp2.igen"
  int i;
  signed64 v0;
  signed32 v1 = (signed32)GPR[rs];
  signed32 v2 = (signed32)GPR[rt];
  if (op == 0) // ADD
    v0 = (signed64)v1 + (signed64)v2;
  else // SUB
    v0 = (signed64)v1 - (signed64)v2;
  if (round == 1)
    v0 = (v0 + 1) >> 1;
  else
    v0 = v0 >> 1;
  GPR[rd] = EXTEND32 (v0);
}
#line 2526 "support.c"

INLINE_SUPPORT\
(void)
do_x_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 281 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)((v2 & 0xffff0000) >> 16);
      result = (signed32)h1 * (signed32)h2;
      if (op == 0) // DPAX
        prod += (signed64)result;
      else // DPSX
        prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2555 "support.c"

INLINE_SUPPORT\
(void)
do_qx_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int sat)
{
#line 307 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  signed64 max, min;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)((v2 & 0xffff0000) >> 16);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = 0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;
      if (op == 0) // DPAQX
        prod += (signed64)result;
      else // DPSQX
        prod -= (signed64)result;
    }
  // Saturation on the accumulator.
  if (sat == 1)
    {
      max = (signed64) 0x7fffffffLL;
      min = (signed64) 0xffffffff80000000LL;
      if (prod > max)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  prod = max;
  	}
      else if (prod < min)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  prod = min;
  	}
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 2607 "support.c"


#endif /* _SUPPORT_C_*/
