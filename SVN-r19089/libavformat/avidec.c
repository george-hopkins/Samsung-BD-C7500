/*
 * AVI demuxer
 * Copyright (c) 2001 Fabrice Bellard
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

//#define DEBUG
//#define DEBUG_SEEK

#include "libavutil/intreadwrite.h"
#include "libavutil/bswap.h"
#include "avformat.h"
#include "avi.h"
#include "dv.h"
#include "riff.h"

#undef NDEBUG
#include <assert.h>

typedef struct AVIStream {
    int64_t frame_offset; /* current frame (video) or byte (audio) counter
                         (used to compute the pts) */
    int remaining;
    int packet_size;

    int scale;
    int rate;
    int sample_size; /* size of one sample (or packet) (in the rate/scale sense) in bytes */

    int64_t cum_len; /* temporary storage (used during seek) */

    int prefix;                       ///< normally 'd'<<8 + 'c' or 'w'<<8 + 'b'
    int prefix_count;
    uint32_t pal[256];
    int has_pal;
} AVIStream;

typedef struct {
    int64_t  riff_end;
    int64_t  movi_end;
    int64_t  fsize;
    int64_t movi_list;
    int64_t last_pkt_pos;
    int index_loaded;
    int is_odml;
    int non_interleaved;
    int stream_index;
    DVDemuxContext* dv_demux;
} AVIContext;

static const char avi_headers[][8] = {
    { 'R', 'I', 'F', 'F',    'A', 'V', 'I', ' ' },
    { 'R', 'I', 'F', 'F',    'A', 'V', 'I', 'X' },
    { 'R', 'I', 'F', 'F',    'A', 'V', 'I', 0x19},
    { 'O', 'N', '2', ' ',    'O', 'N', '2', 'f' },
    { 'R', 'I', 'F', 'F',    'A', 'M', 'V', ' ' },
    { 0 }
};

static int avi_load_index(AVFormatContext *s);
static int guess_ni_flag(AVFormatContext *s);
extern int avi_seek_available(AVFormatContext *s, int stream_index, int64_t wanted_timestamp, int flags);
static int64_t last_video_pkt_timestamp;
static int64_t isODML;
static int avi_simple_index_load;
static int avi_index_believable;
int avi_bitrate_in_header;
#if 0 // compute timestamp by vbr and size
int64_t cherry_duration_from_bitrate[15000];
int cherry_max_index_of_array;
#endif
static int use_index_for_sync;

static int check_idx1(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    uint32_t tag, size;
    int64_t pos= url_ftell(pb);
    int ret = -1;

    if (url_fseek(pb, avi->movi_end, SEEK_SET) < 0)
        goto the_end; // maybe truncated file

    for(;;) {
        if (url_feof(pb))
            break;
        tag = get_le32(pb);
        size = get_le32(pb);

        switch(tag) {
        case MKTAG('i', 'd', 'x', '1'):
            av_log(NULL,AV_LOG_INFO,"[%s][%d] There are IDX1 chunk...\n",__FUNCTION__,__LINE__);
            ret = 0;
                goto the_end;
            break;
        default:
        skip:
            size += (size & 1);
            if (url_fseek(pb, size, SEEK_CUR) < 0)
                goto the_end; // something is wrong here
            break;
        }
    }
 the_end:
    url_fseek(pb, pos, SEEK_SET);
    return ret;
}


#ifdef DEBUG
static void print_tag(const char *str, unsigned int tag, int size)
{
    dprintf(NULL, "%s: tag=%c%c%c%c size=0x%x\n",
           str, tag & 0xff,
           (tag >> 8) & 0xff,
           (tag >> 16) & 0xff,
           (tag >> 24) & 0xff,
           size);
}
#endif

static int get_riff(AVFormatContext *s, ByteIOContext *pb)
{
    AVIContext *avi = s->priv_data;
    char header[8];
    int i;

    /* check RIFF header */
    get_buffer(pb, header, 4);
    avi->riff_end = get_le32(pb);   /* RIFF chunk size */
    avi->riff_end += url_ftell(pb); /* RIFF chunk end */
    get_buffer(pb, header+4, 4);

    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(header, avi_headers[i], 8))
            break;
    if(!avi_headers[i][0])
        return -1;

    if(header[7] == 0x19)
        av_log(s, AV_LOG_INFO, "This file has been generated by a totally broken muxer.\n");

    return 0;
}

static int read_braindead_odml_indx(AVFormatContext *s, int frame_num){
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    int longs_pre_entry= get_le16(pb);
    int index_sub_type = get_byte(pb);
    int index_type     = get_byte(pb);
    int entries_in_use = get_le32(pb);
    int chunk_id       = get_le32(pb);
    int64_t base       = get_le64(pb);
    int stream_id= 10*((chunk_id&0xFF) - '0') + (((chunk_id>>8)&0xFF) - '0');
    AVStream *st;
    AVIStream *ast;
    int i;
    int64_t last_pos= -1;
    int64_t filesize= url_fsize(s->pb);

#ifdef DEBUG_SEEK
    av_log(s, AV_LOG_ERROR, "longs_pre_entry:%d index_type:%d entries_in_use:%d chunk_id:%X base:%16"PRIX64"\n",
        longs_pre_entry,index_type, entries_in_use, chunk_id, base);
#endif

    if(stream_id > s->nb_streams || stream_id < 0)
        return -1;
    st= s->streams[stream_id];
    ast = st->priv_data;

    if(index_sub_type)
        return -1;

    get_le32(pb);

    if(index_type && longs_pre_entry != 2)
        return -1;
    if(index_type>1)
        return -1;

    if(filesize > 0 && base >= filesize){
        av_log(s, AV_LOG_ERROR, "ODML index invalid\n");
        if(base>>32 == (base & 0xFFFFFFFF) && (base & 0xFFFFFFFF) < filesize && filesize <= 0xFFFFFFFF)
            base &= 0xFFFFFFFF;
        else
            return -1;
    }
    //av_log(NULL, AV_LOG_INFO , "longs_pre_entry:%d index_type:%d entries_in_use:%d chunk_id:%X base:%16"PRIX64"\n",longs_pre_entry,index_type, entries_in_use, chunk_id, base);
    for(i=0; i<entries_in_use; i++){
        if(index_type){
            int64_t pos= get_le32(pb) + base - 8;
            int len    = get_le32(pb);
            int key= len >= 0;
            len &= 0x7FFFFFFF;

#ifdef DEBUG_SEEK
            av_log(s, AV_LOG_ERROR, "pos:%"PRId64", len:%X\n", pos, len);
#endif
            if(url_feof(pb))
                return -1;

            if(last_pos == pos || pos == base - 8)
                avi->non_interleaved= 1;
            if(avi_simple_index_load == 1) {
                // sample_size = 0이면서 오디오인 스트림... 고려...
                // Video index loading
                if(!ast->sample_size) {
		    if(key) {
                        av_add_index_entry(st, pos, ast->cum_len, len, 0, AVINDEX_KEYFRAME);
                    } else  if(!(i % 2)) {
                        av_add_index_entry(st, pos, ast->cum_len, len, 0, 0);
                    }
                // Audio index loading
                } else {
                    if(!(i%10)) {
                av_add_index_entry(st, pos, ast->cum_len, len, 0, key ? AVINDEX_KEYFRAME : 0);
                    } 
                }
            }
            else if(last_pos != pos && (len || !ast->sample_size)) {
                if(len != 0) {
                av_add_index_entry(st, pos, ast->cum_len, len, 0, key ? AVINDEX_KEYFRAME : 0);
                } else if (len == 0) {
			av_add_index_entry(st, pos, ast->cum_len, len, 0, 0);
                }
            }

            if(ast->sample_size)
                ast->cum_len += len;
            else
                ast->cum_len ++;
            last_pos= pos;
        }else{
            int64_t offset, pos;
            int duration;
            offset = get_le64(pb);
            get_le32(pb);       /* size */
            duration = get_le32(pb);

            if(url_feof(pb))
                return -1;

            pos = url_ftell(pb);

            url_fseek(pb, offset+8, SEEK_SET);
            read_braindead_odml_indx(s, frame_num);
            frame_num += duration;

            url_fseek(pb, pos, SEEK_SET);
        }
    }
    avi->index_loaded=1;
    return 0;
}

static void clean_index(AVFormatContext *s){
    int i;
    int64_t j;

    for(i=0; i<s->nb_streams; i++){
        AVStream *st = s->streams[i];
        AVIStream *ast = st->priv_data;
        int n= st->nb_index_entries;
        int max= ast->sample_size;
        int64_t pos, size, ts;

        if(n != 1 || ast->sample_size==0)
            continue;

        while(max < 1024) max+=max;

        pos= st->index_entries[0].pos;
        size= st->index_entries[0].size;
        ts= st->index_entries[0].timestamp;

        for(j=0; j<size; j+=max){
            av_add_index_entry(st, pos+j, ts+j, FFMIN(max, size-j), 0, AVINDEX_KEYFRAME);
        }
    }
}

static int avi_read_tag(AVFormatContext *s, const char *key, unsigned int size)
{
    ByteIOContext *pb = s->pb;
    uint8_t value[1024];

    int64_t i = url_ftell(pb);
    size += (size & 1);
    get_strz(pb, value, sizeof(value));
    url_fseek(pb, i+size, SEEK_SET);

    return av_metadata_set(&s->metadata, key, value);
}

static int avi_read_stream_tag(AVFormatContext *s, AVStream *st, const char *key, unsigned int size)
{
    ByteIOContext *pb = s->pb;
    uint8_t value[1024];

    int64_t i = url_ftell(pb);
    size += (size & 1);
    get_strz(pb, value, sizeof(value));
    url_fseek(pb, i+size, SEEK_SET);
    av_log(NULL,AV_LOG_INFO,"[%s] %s \n", __FUNCTION__,value);
    return av_metadata_set(&st->metadata, key, value);
}


static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap)
{
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    unsigned int tag, tag1, handler;
    int codec_type, stream_index, frame_period, bit_rate;
    unsigned int size, nb_frames;
    int i;
    AVStream *st;
    AVIStream *ast = NULL;
    int avih_width=0, avih_height=0;
    int amv_file_format=0;
    uint64_t list_end = 0;
    int iResetSampleSize = 0;

    int totalstreams =0;
    last_video_pkt_timestamp = -1;
    use_index_for_sync = 0; // initialize it.
    isODML = 0;
    avi_simple_index_load = 0;
    avi_bitrate_in_header = 0;
	avi_index_believable = 1;
#ifdef Uniplayer_DRM/*****************************************by uniplayer for Divx DRM*/
		int ss;
		int a;
		int m;
		int sss;
    s->Is_This_DRM_File = 0;
	s->samsung_divx = 0;
    s->Read_point = 0;//shintest
    s->Write_point = 0;//shintest
#endif/*******************************************************by uniplayer for Divx DRM*/

    avi->stream_index= -1;

    if (get_riff(s, pb) < 0)
        return -1;

    avi->fsize = url_fsize(pb);

    if(avi->fsize<=0)
        avi->fsize= avi->riff_end == 8 ? INT64_MAX : avi->riff_end;

    /* first list tag */
    stream_index = -1;
    codec_type = -1;
    frame_period = 0;
    for(;;) {
        if (url_feof(pb))
            goto fail;
        tag = get_le32(pb);
        size = get_le32(pb);
#ifdef DEBUG
        print_tag("tag", tag, size);
#endif
        //av_log(NULL,AV_LOG_INFO,"[%s] tag=%c%c%c%c\n",__FUNCTION__,tag & 0xff,(tag >> 8) & 0xff,(tag >> 16) & 0xff,(tag >> 24) & 0xff);
        switch(tag) {
        case MKTAG('L', 'I', 'S', 'T'):
            list_end = url_ftell(pb) + size;
            /* Ignored, except at start of video packets. */
            tag1 = get_le32(pb);
#ifdef DEBUG
            print_tag("list", tag1, 0);
#endif
            if (tag1 == MKTAG('m', 'o', 'v', 'i')) {
                avi->movi_list = url_ftell(pb) - 4;
                if(size) avi->movi_end = avi->movi_list + size + (size & 1);
                else     avi->movi_end = url_fsize(pb);
                dprintf(NULL, "movi end=%"PRIx64"\n", avi->movi_end);
                goto end_of_header;
            }
            break;
        case MKTAG('d', 'm', 'l', 'h'):
            avi->is_odml = 1;
            url_fskip(pb, size + (size & 1));
            break;
        case MKTAG('a', 'm', 'v', 'h'):
            amv_file_format=1;
        case MKTAG('a', 'v', 'i', 'h'):
            /* AVI header */
            /* using frame_period is bad idea */
            frame_period = get_le32(pb);
            avi_bitrate_in_header  = bit_rate = get_le32(pb) * 8;  // modified by fscherry 091218 for brand new days.avi duration error
            av_log(NULL,AV_LOG_INFO,"[%s][%d]avi_bitrate_in_header = %d \n",__FUNCTION__,__LINE__,avi_bitrate_in_header);
            get_le32(pb);
            avi->non_interleaved |= get_le32(pb) & AVIF_MUSTUSEINDEX;

            url_fskip(pb, 2 * 4);
            totalstreams = get_le32(pb); // streams
            av_log(NULL,AV_LOG_INFO,"[%s][%d] number of streams = [%d] \n",__FUNCTION__,__LINE__,totalstreams);
            get_le32(pb);
            avih_width=get_le32(pb);
            avih_height=get_le32(pb);

            // check load index or not
            if(avi->fsize >= (0x80000000 + 0x200000000 )) { // 2GB + 8GB = 10GB , this is max
                // do not try index loading
                av_log(NULL,AV_LOG_INFO,"\nFILE SIZE IS OVER 10GB , So CANNOT SUPPORT SEEK BECAUSE OF MEMORY LIMITATION\n");
                //pb->is_streamed = 1;
                avi_simple_index_load = 1;
            }else if((avi->fsize > 0x80000000) && (avi->fsize < (0x80000000 + 0x200000000 ))) { //2// 2GB
                //check number of stream
                if(totalstreams >= 4) {
                    // this is dangerous, so do not try to load index.
                    av_log(NULL,AV_LOG_INFO,"\nFILE SIZE IS OVER 2GB and Total number of Streams are over 8. So CHANGE TO SIMPLE INDEX MODE BECAUSE OF MEMORY LIMITATION\n");
                    avi_simple_index_load = 1;
                }
            }

#ifdef Uniplayer_DRM/*****************************************by uniplayer for Divx DRM*/
		ss = get_byte(pb);
		a = get_byte(pb);
		m = get_byte(pb);
		sss = get_byte(pb);
		if((ss == 0x53)&& (a == 0x41)&& (m == 0x4d)&& (sss == 0x53)){
			av_log(NULL,AV_LOG_INFO,"\n\n<SAMSUNG DIVX DRMED FILE FOUND !!!!!>\n\n\n");
			s->samsung_divx = 1;
		}
		url_fskip(pb, size - ((10 * 4)+4));
#else/*******************************************************by uniplayer for Divx DRM*/
url_fskip(pb, size - 10 * 4);
#endif
            break;
        case MKTAG('s', 't', 'r', 'h'):
            /* stream header */

            tag1 = get_le32(pb);
            handler = get_le32(pb); /* codec tag */

            if(tag1 == MKTAG('p', 'a', 'd', 's')){
                url_fskip(pb, size - 8);
                break;
            }else{
                stream_index++;
                st = av_new_stream(s, stream_index);
                if (!st)
                    goto fail;

                ast = av_mallocz(sizeof(AVIStream));
                if (!ast)
                    goto fail;
                st->priv_data = ast;
            }
            if(amv_file_format)
                tag1 = stream_index ? MKTAG('a','u','d','s') : MKTAG('v','i','d','s');

#ifdef DEBUG
            print_tag("strh", tag1, -1);
#endif
            if(tag1 == MKTAG('i', 'a', 'v', 's') || tag1 == MKTAG('i', 'v', 'a', 's')){
                int64_t dv_dur;

                /*
                 * After some consideration -- I don't think we
                 * have to support anything but DV in type1 AVIs.
                 */
                if (s->nb_streams != 1)
                    goto fail;

                if (handler != MKTAG('d', 'v', 's', 'd') &&
                    handler != MKTAG('d', 'v', 'h', 'd') &&
                    handler != MKTAG('d', 'v', 's', 'l'))
                   goto fail;

                ast = s->streams[0]->priv_data;
                av_freep(&s->streams[0]->codec->extradata);
                av_freep(&s->streams[0]);
                s->nb_streams = 0;
                if (CONFIG_DV_DEMUXER) {
                    avi->dv_demux = dv_init_demux(s);
                    if (!avi->dv_demux)
                        goto fail;
                }
                s->streams[0]->priv_data = ast;
                url_fskip(pb, 3 * 4);
                ast->scale = get_le32(pb);
                ast->rate = get_le32(pb);
                url_fskip(pb, 4);  /* start time */

                dv_dur = get_le32(pb);
                if (ast->scale > 0 && ast->rate > 0 && dv_dur > 0) {
                    dv_dur *= AV_TIME_BASE;
                    s->duration = av_rescale(dv_dur, ast->scale, ast->rate);
                }
                /*
                 * else, leave duration alone; timing estimation in utils.c
                 *      will make a guess based on bitrate.
                 */

                stream_index = s->nb_streams - 1;
                url_fskip(pb, size - 9*4);
                break;
            }

            assert(stream_index < s->nb_streams);
            st->codec->stream_codec_tag= handler;

            get_le32(pb); /* flags */
            get_le16(pb); /* priority */
            get_le16(pb); /* language */
            get_le32(pb); /* initial frame */
            ast->scale = get_le32(pb);
            ast->rate = get_le32(pb);
            if(!(ast->scale && ast->rate)){
                av_log(s, AV_LOG_WARNING, "scale/rate is %u/%u which is invalid. (This file has been generated by broken software.)\n", ast->scale, ast->rate);
                if(frame_period){
                    ast->rate = 1000000;
                    ast->scale = frame_period;
                }else{
                    ast->rate = 25;
                    ast->scale = 1;
                }
            }
            av_set_pts_info(st, 64, ast->scale, ast->rate);

            ast->cum_len=get_le32(pb); /* start */
            nb_frames = get_le32(pb);

            st->start_time = 0;
            st->duration = nb_frames;
            get_le32(pb); /* buffer size */
            get_le32(pb); /* quality */
            ast->sample_size = get_le32(pb); /* sample ssize */
            //av_log(NULL,AV_LOG_INFO,"\n\n [%s][%d] sample_size = %d \n\n ",__FUNCTION__,__LINE__, ast->sample_size);
            ast->cum_len *= FFMAX(1, ast->sample_size);
//            av_log(s, AV_LOG_DEBUG, "%d %d %d %d\n", ast->rate, ast->scale, ast->start, ast->sample_size);

            switch(tag1) {
            case MKTAG('v', 'i', 'd', 's'):
                codec_type = CODEC_TYPE_VIDEO;

                ast->sample_size = 0;
                break;
            case MKTAG('a', 'u', 'd', 's'):
                codec_type = CODEC_TYPE_AUDIO;
                av_log(NULL,AV_LOG_INFO,"\n\n [%s][%d] auds tag: sample_size = %d \n\n ",__FUNCTION__,__LINE__, ast->sample_size);
                if(ast->sample_size == 0) { 
                    iResetSampleSize = 888;
                    ast->sample_size=1;
                }
                break;
            case MKTAG('t', 'x', 't', 's'):
                //FIXME
                codec_type = CODEC_TYPE_DATA; //CODEC_TYPE_SUB ?  FIXME
                break;
            case MKTAG('d', 'a', 't', 's'):
                codec_type = CODEC_TYPE_DATA;
                break;
            default:
                av_log(s, AV_LOG_ERROR, "unknown stream type %X\n", tag1);
                goto fail;
            }
            ast->frame_offset= ast->cum_len;
            url_fskip(pb, size - 12 * 4);
            break;
        case MKTAG('s', 't', 'r', 'f'):
            /* stream header */
            if (stream_index >= (unsigned)s->nb_streams || avi->dv_demux) {
                url_fskip(pb, size);
            } else {
                uint64_t cur_pos = url_ftell(pb);
                if (cur_pos < list_end)
                    size = FFMIN(size, list_end - cur_pos);
                st = s->streams[stream_index];
                switch(codec_type) {
                case CODEC_TYPE_VIDEO:
                    if(amv_file_format){
                        st->codec->width=avih_width;
                        st->codec->height=avih_height;
                        st->codec->codec_type = CODEC_TYPE_VIDEO;
                        st->codec->codec_id = CODEC_ID_AMV;
                        url_fskip(pb, size);
                        break;
                    }
                    get_le32(pb); /* size */
                    st->codec->width = get_le32(pb);
                    st->codec->height = (int32_t)get_le32(pb);
                    get_le16(pb); /* panes */
                    st->codec->bits_per_coded_sample= get_le16(pb); /* depth */
                    tag1 = get_le32(pb);
                    get_le32(pb); /* ImageSize */
                    get_le32(pb); /* XPelsPerMeter */
                    get_le32(pb); /* YPelsPerMeter */
                    get_le32(pb); /* ClrUsed */
                    get_le32(pb); /* ClrImportant */

                    if ((tag1 == MKTAG('D', 'X', 'S', 'B')) || (tag1 == MKTAG('D','X','S','A'))) {
 		   	st->codec->codec_tag = tag1;
                        unsigned int sub_tag = get_le32(pb);
                        if(sub_tag == MKTAG('s', 't', 'r', 'n'))
                        {
                            unsigned int string_size = get_le32(pb);                           
                            avi_read_stream_tag(s , st , "sub-title" , string_size);
                            //AVMetadataTag *tag= av_metadata_get(st->metadata,"sub-title", NULL, AV_METADATA_MATCH_CASE);
                            //av_log(NULL,AV_LOG_INFO,"sub-title = %s\n", tag->value);
                        }                        
                        st->codec->codec_type = CODEC_TYPE_SUBTITLE;
                        st->codec->codec_tag = tag1;
                        st->codec->codec_id = CODEC_ID_XSUB;
                        break;
                    }

                    if(size > 10*4 && size<(1<<30)){
                        st->codec->extradata_size= size - 10*4;
                        st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
                        if (!st->codec->extradata) {
                            st->codec->extradata_size= 0;
                            return AVERROR(ENOMEM);
                        }
                        get_buffer(pb, st->codec->extradata, st->codec->extradata_size);
                    }

                    if(st->codec->extradata_size & 1) //FIXME check if the encoder really did this correctly
                        get_byte(pb);

                    /* Extract palette from extradata if bpp <= 8. */
                    /* This code assumes that extradata contains only palette. */
                    /* This is true for all paletted codecs implemented in FFmpeg. */
                    if (st->codec->extradata_size && (st->codec->bits_per_coded_sample <= 8)) {
                        st->codec->palctrl = av_mallocz(sizeof(AVPaletteControl));
#ifdef WORDS_BIGENDIAN
                        for (i = 0; i < FFMIN(st->codec->extradata_size, AVPALETTE_SIZE)/4; i++)
                            st->codec->palctrl->palette[i] = bswap_32(((uint32_t*)st->codec->extradata)[i]);
#else
                        memcpy(st->codec->palctrl->palette, st->codec->extradata,
                               FFMIN(st->codec->extradata_size, AVPALETTE_SIZE));
#endif
                        st->codec->palctrl->palette_changed = 1;
                    }

#ifdef DEBUG
                    print_tag("video", tag1, 0);
#endif
                    st->codec->codec_type = CODEC_TYPE_VIDEO;
                    st->codec->codec_tag = tag1;
                    st->codec->codec_id = codec_get_id(codec_bmp_tags, tag1);
                    st->need_parsing = AVSTREAM_PARSE_HEADERS; // This is needed to get the pict type which is necessary for generating correct pts.

                    if(st->codec->codec_tag==0 && st->codec->height > 0 && st->codec->extradata_size < 1U<<30){
                        st->codec->extradata_size+= 9;
                        st->codec->extradata= av_realloc(st->codec->extradata, st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
                        if(st->codec->extradata)
                            memcpy(st->codec->extradata + st->codec->extradata_size - 9, "BottomUp", 9);
                    }
                    st->codec->height= FFABS(st->codec->height);

//                    url_fskip(pb, size - 5 * 4);
                    break;
                case CODEC_TYPE_AUDIO:
                    get_wav_header(pb, st->codec, size);
#if 0  // compute timestamp by vbr and size
                    memset(cherry_duration_from_bitrate,0,sizeof(cherry_duration_from_bitrate));
                    cherry_max_index_of_array= 0;
#endif                    
                    if(ast->sample_size && st->codec->block_align && ast->sample_size != st->codec->block_align){
                        av_log(s, AV_LOG_WARNING, "sample size (%d) != block align (%d)\n", ast->sample_size, st->codec->block_align);
                        ast->sample_size= st->codec->block_align;
                        if(iResetSampleSize == 888) {
                            av_log(NULL,AV_LOG_INFO,"So..Re Reset samplesize\n");
                           ast->sample_size = 0;
                           iResetSampleSize = 0;
                        }
                    }
                    if (size%2) /* 2-aligned (fix for Stargate SG-1 - 3x18 - Shades of Grey.avi) */
                        url_fskip(pb, 1);
                    /* Force parsing as several audio frames can be in
                     * one packet and timestamps refer to packet start. */
                    st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;
                    /* ADTS header is in extradata, AAC without header must be
                     * stored as exact frames. Parser not needed and it will
                     * fail. */
                    if (st->codec->codec_id == CODEC_ID_AAC && st->codec->extradata_size)
                        st->need_parsing = AVSTREAM_PARSE_NONE;
                    /* AVI files with Xan DPCM audio (wrongly) declare PCM
                     * audio in the header but have Axan as stream_code_tag. */
                    if (st->codec->stream_codec_tag == AV_RL32("Axan")){
                        st->codec->codec_id  = CODEC_ID_XAN_DPCM;
                        st->codec->codec_tag = 0;
                    }
                    if (amv_file_format)
                        st->codec->codec_id  = CODEC_ID_ADPCM_IMA_AMV;
                    break;
                default:
                    st->codec->codec_type = CODEC_TYPE_DATA;
                    st->codec->codec_id= CODEC_ID_NONE;
                    st->codec->codec_tag= 0;
                    url_fskip(pb, size);
                    break;
                }
            }
            break;
        case MKTAG('i', 'n', 'd', 'x'):
            i= url_ftell(pb);
            av_log(NULL,AV_LOG_INFO,"[%s][%d] There are indx chunk !!\n",__FUNCTION__,__LINE__);
            if(!url_is_streamed(pb) && !(s->flags & AVFMT_FLAG_IGNIDX)){
                av_log(NULL,AV_LOG_INFO,"[%s][%d] load indx chunk ... !!\n",__FUNCTION__,__LINE__);
                isODML = 1;
                read_braindead_odml_indx(s, 0);
            }
            url_fseek(pb, i+size, SEEK_SET);
            break;
        case MKTAG('v', 'p', 'r', 'p'):
            if(stream_index < (unsigned)s->nb_streams && size > 9*4){
                AVRational active, active_aspect;

                st = s->streams[stream_index];
                get_le32(pb);
                get_le32(pb);
                get_le32(pb);
                get_le32(pb);
                get_le32(pb);

                active_aspect.den= get_le16(pb);
                active_aspect.num= get_le16(pb);
                active.num       = get_le32(pb);
                active.den       = get_le32(pb);
                get_le32(pb); //nbFieldsPerFrame

                if(active_aspect.num && active_aspect.den && active.num && active.den){
                    st->sample_aspect_ratio= av_div_q(active_aspect, active);
//av_log(s, AV_LOG_ERROR, "vprp %d/%d %d/%d\n", active_aspect.num, active_aspect.den, active.num, active.den);
                }
                size -= 9*4;
            }
            url_fseek(pb, size, SEEK_CUR);
            break;
        case MKTAG('I', 'N', 'A', 'M'):
            avi_read_tag(s, "Title", size);
            break;
        case MKTAG('I', 'A', 'R', 'T'):
            avi_read_tag(s, "Artist", size);
            break;
        case MKTAG('I', 'C', 'O', 'P'):
            avi_read_tag(s, "Copyright", size);
            break;
        case MKTAG('I', 'C', 'M', 'T'):
            avi_read_tag(s, "Comment", size);
            break;
        case MKTAG('I', 'G', 'N', 'R'):
            avi_read_tag(s, "Genre", size);
            break;
        case MKTAG('I', 'P', 'R', 'D'):
            avi_read_tag(s, "Album", size);
            break;
        case MKTAG('I', 'P', 'R', 'T'):
            avi_read_tag(s, "Track", size);
            break;
#ifdef Uniplayer_DRM//**********************************************************by Uniplayer team for Divx DRM
	 case MKTAG('s', 't', 'r', 'd'):
                    i = url_ftell(pb);
                    // check drm header is valid or not
                    int dwVersion = get_le32(pb);
                    int dwSize = get_le32(pb);
                    int drmHeader = get_le32(pb);
                    //av_log(NULL,AV_LOG_INFO,"CHUNK - strd : Curr_pos=%d, chunksize=%d , dwVersion = %d, dwSize = %d , drmHeader = %d\n",i,size,dwVersion,dwSize,drmHeader);
                    if(!dwVersion) {
        		   av_log(NULL,AV_LOG_INFO,"DRM Header is Invalid, This is not DRM file!!! \n");
                           s->Is_This_DRM_File = 0;
                    } else if(dwVersion > 2) {
                    	// we do not support it.
			av_log(NULL,AV_LOG_INFO,"DRM file BUT not supported version. so quit. \n");
                    	goto fail;
                    }	else {
	 		s->Is_This_DRM_File = 1;
			av_log(NULL,AV_LOG_INFO,"********** ******************** *********** \n");
			av_log(NULL,AV_LOG_INFO,"********** This was procted with DRM *********** \n");
			av_log(NULL,AV_LOG_INFO,"********** ******************** *********** \n");
                       	if(!strcmp(url_fileno(pb)->prot->name , "dlna")) {
                        av_log(NULL,AV_LOG_INFO,"********** *******************  *********** \n");
                        av_log(NULL,AV_LOG_INFO,"********** DLNA / DRM CONTENTS *********** \n");
                        av_log(NULL,AV_LOG_INFO,"********** *******************  *********** \n");
                        pb->is_streamed = 1;
                   	}
                    }
                    url_fseek(pb, i+size, SEEK_SET);
                    break;
#endif//**************************************************************************by Uniplayer team for Divx DRM

        default:
            if(size > 1000000){
                av_log(s, AV_LOG_ERROR, "Something went wrong during header parsing, "
                                        "I will ignore it and try to continue anyway.\n");
                avi->movi_list = url_ftell(pb) - 4;
                avi->movi_end  = url_fsize(pb);
                goto end_of_header;
            }
            /* skip tag */
            size += (size & 1);
            url_fskip(pb, size);
            break;
        }
    }
 end_of_header:
    /* check stream number */
    if (stream_index != s->nb_streams - 1) {
    fail:
        return -1;
    }

    if(isODML) {
        if(!check_idx1(s)) {
        // there are idx1 chunk
            isODML = 0;
        }
        // index reload using idx1 ?  -> no..we belive indx
    }

    if(!avi->index_loaded && !url_is_streamed(pb))
        avi_load_index(s);
    avi->index_loaded = 1;
    avi->non_interleaved |= guess_ni_flag(s);
    if(pb->is_optical == 1) {
        av_log(NULL,AV_LOG_INFO,"[AVI HEADER] THIS IS OPTICAL..! Set Interleaved \n");
        avi->non_interleaved = 0;
    }
    if(avi_simple_index_load == 1) {
        av_log(NULL,AV_LOG_INFO,"[AVI HEADER] SimpleMode for big entries. Change mode to interleave.. Original[%d] \n",avi->non_interleaved);
        avi->non_interleaved = 0;
    }
    if(avi->non_interleaved) {
        av_log(s, AV_LOG_INFO, "non-interleaved AVI\n");
        clean_index(s);
    }

    //av_log(NULL,AV_LOG_INFO,"[avi header] avi->non_interleaved = %d , avi->index_loaded =%d, is_streamed = %d \n",avi->non_interleaved,avi->index_loaded,pb->is_streamed);
#if 0
    if(1) {
        int j;
        for(j = 0; j < s->nb_streams; j++) {        
        int i=0;
            AVStream *st = s->streams[j];
            av_log(NULL,AV_LOG_INFO,"\nPRINT INDEX ENTRIES! (1) [%d]\n",st->nb_index_entries);            
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
            
            switch(st->codec->codec_type) {
                case CODEC_TYPE_VIDEO:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE VIDEO\n\n");
                    break;
                case CODEC_TYPE_AUDIO:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE AUDIO\n\n");
                    break;
                default:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE ELSE\n\n");
                    break;
            }
            
        for(i=0;i<st->nb_index_entries;i++) {
            av_log(NULL,AV_LOG_INFO,"IDX[%d] POS[%lld],TS[%lld], FLAGS[%d],SIZE[%d],MIN_DISTANCE[%d]\n"
                ,i
                ,st->index_entries[i].pos
                ,st->index_entries[i].timestamp
                ,st->index_entries[i].flags
                ,st->index_entries[i].size
                ,st->index_entries[i].min_distance);
        }
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
        }
    }
#endif



    return 0;
}

static int get_stream_idx(int *d){
    if(    d[0] >= '0' && d[0] <= '9'
        && d[1] >= '0' && d[1] <= '9'){
        return (d[0] - '0') * 10 + (d[1] - '0');
    }else{
        return 100; //invalid stream ID
    }
}

static int avi_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    int n, d[8];
    unsigned int size;
    int64_t i, sync;
    void* dstr;
    int current_st_index_of_table;
#ifdef Uniplayer_DRM//************************************* for Divx DRM
    unsigned char num = 0;	
    pkt->sDRMinfo.DRM_Key_Index = 0;
	pkt->sDRMinfo.DRM_Offset = 0;
	pkt->sDRMinfo.DRM_Length = 0;
	pkt->sDRMinfo.DRM_Updated_Flag = 0;	
#endif//***************************************************** for Divx DRM
    //av_log(NULL,AV_LOG_INFO,"[%d] avi_read_packet called : avi->stream_index = %d \n",__LINE__, avi->stream_index);
    if (CONFIG_DV_DEMUXER && avi->dv_demux) {
        int size = dv_get_packet(avi->dv_demux, pkt);
        if (size >= 0)
            return size;
    }

    if(avi->non_interleaved){
        int best_stream_index = 0;
        AVStream *best_st= NULL;
        AVIStream *best_ast;
        int64_t best_ts= INT64_MAX;
        int i;

        for(i=0; i<s->nb_streams; i++){
            AVStream *st = s->streams[i];
            AVIStream *ast = st->priv_data;
            int64_t ts= ast->frame_offset;
            int64_t last_ts;

            if(!st->nb_index_entries)
                continue;

           last_ts = st->index_entries[st->nb_index_entries - 1].timestamp;
           if(!ast->remaining && ts > last_ts)
               continue;

            if(use_index_for_sync == 77) {
                // FIXME : this is not considered Subtitle stream. ..fscherry
                int target_index;
                target_index = av_index_search_timestamp(st, ts, AVSEEK_FLAG_ANY);
                ts = av_rescale_q(target_index, st->time_base, (AVRational){1, AV_TIME_BASE});
            } else {
            ts = av_rescale_q(ts, st->time_base, (AVRational){FFMAX(1, ast->sample_size), AV_TIME_BASE});
            }

//            av_log(s, AV_LOG_DEBUG, "%"PRId64" %d/%d %"PRId64"\n", ts, st->time_base.num, st->time_base.den, ast->frame_offset);
//            if(ts < best_ts && st->nb_index_entries){
            if(ts < best_ts){
                best_ts= ts;
                best_st= st;
                best_stream_index= i;
            }
        }
        if(!best_st)
            return -1;

        best_ast = best_st->priv_data;
        if(use_index_for_sync == 77) {
            //get index from PTS
            best_ts = av_rescale_q(best_ts, (AVRational){1, AV_TIME_BASE}, best_st->time_base);                    
            
        } else {
        best_ts = av_rescale_q(best_ts, (AVRational){FFMAX(1, best_ast->sample_size), AV_TIME_BASE}, best_st->time_base);
        }

        if(use_index_for_sync == 77) {
            i = best_ts;
            if(i>=0)
                best_ast->frame_offset= best_st->index_entries[i].timestamp;            
        }
        else if(best_ast->remaining)
            i= av_index_search_timestamp(best_st, best_ts, AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD);
        else{
            i= av_index_search_timestamp(best_st, best_ts, AVSEEK_FLAG_ANY);
            if(i>=0)
                best_ast->frame_offset= best_st->index_entries[i].timestamp;
        }

//        av_log(s, AV_LOG_DEBUG, "%d\n", i);
        if(i>=0){
            int64_t pos= best_st->index_entries[i].pos;
            current_st_index_of_table = i;
            pos += best_ast->packet_size - best_ast->remaining;
            url_fseek(s->pb, pos + 8, SEEK_SET);
//        av_log(s, AV_LOG_DEBUG, "pos=%"PRId64"\n", pos);

            assert(best_ast->remaining <= best_ast->packet_size);

            avi->stream_index= best_stream_index;
            if(!best_ast->remaining) {
                // DivxDRM with openDML format
                if(s->Is_This_DRM_File && isODML) {
                    if(s->streams[best_stream_index]->codec->codec_type == CODEC_TYPE_VIDEO) {

                        if(s->samsung_divx == 0) {
                            num = s->Write_point;
                            s->DRM_information[num].DRM_Key_Index =  get_byte(pb) + (get_byte(pb) << 8);
                            s->DRM_information[num].DRM_Offset = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
                            s->DRM_information[num].DRM_Length = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
                            s->Write_point++;
                            if(s->Write_point > 39)
                            {
                            	s->Write_point = 0;
                            }
                            //pkt->sDRMinfo.DRM_Key_Index = get_byte(pb) + (get_byte(pb) << 8);
                            //pkt->sDRMinfo.DRM_Offset = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
                            //pkt->sDRMinfo.DRM_Length = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
                            pkt->sDRMinfo.DRM_Key_Index = s->DRM_information[num].DRM_Key_Index ;
                            pkt->sDRMinfo.DRM_Offset = s->DRM_information[num].DRM_Offset;
                            pkt->sDRMinfo.DRM_Length = s->DRM_information[num].DRM_Length;
                            pkt->sDRMinfo.DRM_Updated_Flag = 1;
                        } else {
                            av_log(NULL,AV_LOG_INFO,"!!!!! THIS IS ODML FORMAT S-DIVX DRM !!!!\n");
                            av_log(NULL,AV_LOG_INFO,"!!!!! THIS IS ODML FORMAT S-DIVX DRM !!!!\n");
                            av_log(NULL,AV_LOG_INFO,"!!!!! THIS IS ODML FORMAT S-DIVX DRM !!!!\n");
                        }

                        // Get Video Pkt size
                        url_fskip(s->pb , 4);
                        int videopktSize = get_le32(s->pb);
                        //av_log(NULL,AV_LOG_INFO,"[%s][%d] Vkt size = %d \n\n", __FUNCTION__ , __LINE__ , videopktSize);
                        best_ast->packet_size= best_ast->remaining= videopktSize;
                    }
                    else {
                        best_ast->packet_size= best_ast->remaining= best_st->index_entries[i].size;
                        //av_log(NULL,AV_LOG_INFO,"Akt size = %d\n",best_ast->packet_size);
                    }
                } else {
                best_ast->packet_size=
                best_ast->remaining= best_st->index_entries[i].size;
        }
    }
        }
    }

resync:
//    av_log(NULL,AV_LOG_INFO,"[%d] resync : avi->stream_index = %d \n",__LINE__, avi->stream_index);
    if(avi->stream_index >= 0){
        AVStream *st= s->streams[ avi->stream_index ];
        AVIStream *ast= st->priv_data;
        int size, err;

        if(ast->sample_size <= 1) // minorityreport.AVI block_align=1024 sample_size=1 IMA-ADPCM
            size= INT_MAX;
        else if(ast->sample_size < 32)
            size= 64*ast->sample_size;
        else
            size= ast->sample_size;

        if(size > ast->remaining)
            size= ast->remaining;
        avi->last_pkt_pos= url_ftell(pb);
        err= av_get_packet(pb, pkt, size);
        if(err<0)
            return err;

	if(pb->error == -1) 
	{
		av_log(NULL,AV_LOG_INFO,"[%s][%d] pb->error == -1 \n",__FUNCTION__,__LINE__);
		return AVERROR_IO;
	}

        if(ast->has_pal && pkt->data && pkt->size<(unsigned)INT_MAX/2){
            void *ptr= av_realloc(pkt->data, pkt->size + 4*256 + FF_INPUT_BUFFER_PADDING_SIZE);
            if(ptr){
            ast->has_pal=0;
            pkt->size += 4*256;
            pkt->data= ptr;
                memcpy(pkt->data + pkt->size - 4*256, ast->pal, 4*256);
            }else
                av_log(s, AV_LOG_ERROR, "Failed to append palette\n");
        }

        if (CONFIG_DV_DEMUXER && avi->dv_demux) {
            dstr = pkt->destruct;
            size = dv_produce_packet(avi->dv_demux, pkt,
                                    pkt->data, pkt->size);
            pkt->destruct = dstr;
            pkt->flags |= PKT_FLAG_KEY;
        } else {
            /* XXX: How to handle B-frames in AVI? */
            pkt->dts = ast->frame_offset;
//                pkt->dts += ast->start;
            if(ast->sample_size) {
                if(pkt->size >= ast->sample_size && (use_index_for_sync == 0)) {                
                    
                    pkt->dts /= ast->sample_size;
                    
                } else {
                
                    //if(!url_is_streamed(pb)) {
                    if(!pb->is_optical) {
                    // divx certification for E21 & C24 clips
                    use_index_for_sync = 77; // use index for sync.
                                                        // How to confirm?! compute it at each time????
                    pkt->dts = current_st_index_of_table;// in this case, we believe index table for avsync ,we consider one index entry match one video index entry for avsync
                    } else {
                        // for BD, is streamed state..
                        // non-interleaved is not set.
                        use_index_for_sync = 77;                        
                        if(!avi->index_loaded) {
                            avi_load_index(s);
                        }
                        //find index by using pos info
                        //av_log(NULL,AV_LOG_INFO,"pkt->pos %lld\n",pkt->pos);
                        int k;
                        for(k=0;k< st->nb_index_entries;k++) {
                            if( pkt->pos < st->index_entries[k].pos ) {
                                continue;
                            }
                            else if(pkt->pos >= st->index_entries[k].pos) {
                                current_st_index_of_table = k;
                            }
                        }
                        pkt->dts = current_st_index_of_table;
                    }

                }
            }
#if 0 // compute timestamp by vbr and size
            if(ast->sample_size) {
                
                if(pkt->size > ast->sample_size) {
                    
                pkt->dts /= ast->sample_size;
                    
                } else {
                // how can handle interleaved case.. ? in this case, I cannot set 'current_st_index_of_table'
                    st->search_timestamp_from_bitrate = 333;
                    // this is only for audio case
                    //av_log(NULL,AV_LOG_INFO,"current_st_index_of_table  = %d \n", current_st_index_of_table );
                    if(current_st_index_of_table < cherry_max_index_of_array) {
                        
                        pkt->dts = cherry_duration_from_bitrate[current_st_index_of_table] * st->time_base.den / st->time_base.num / AV_TIME_BASE;
                        av_log(NULL,AV_LOG_INFO,"[%s][%d] dts = %lld \n",__FUNCTION__ , __LINE__ ,pkt->dts);
                        
                    } else  {
                    
                        int cherry_index;
                        cherry_index = av_index_search_timestamp(st, ast->frame_offset, AVSEEK_FLAG_ANY);
                        
                        if(cherry_index < 0) {
                            av_log(NULL,AV_LOG_INFO,"[%s][%d] couldn't find index of table \n",__FUNCTION__,__LINE__);
                        }
                        
                        //consider vbr , can get (index+1)th timestamp in advance.
                        if(cherry_index == 0) {
                            
                            cherry_duration_from_bitrate[cherry_index] = 0;
                            cherry_duration_from_bitrate[cherry_index+1] = ((pkt->size * AV_TIME_BASE) / st->codec->bit_rate * 8);
                            av_log(NULL,AV_LOG_INFO,"[%s][%d] st->time_base.den=%d , st->time_base.num=%d timestamp=%lld ,pkt->size=%d ,st->codec->bit_rate =%d\n",__FUNCTION__,__LINE__,st->time_base.den,st->time_base.num,cherry_duration_from_bitrate[cherry_index+1],pkt->size,st->codec->bit_rate );
                            
                        } else if(cherry_index > 0) {

                            cherry_duration_from_bitrate[cherry_index + 1] = cherry_duration_from_bitrate[cherry_index]  + ((pkt->size * AV_TIME_BASE) / st->codec->bit_rate * 8);
                            av_log(NULL,AV_LOG_INFO,"[%s][%d] st->time_base.den=%d , st->time_base.num=%d timestamp=%lld ,pkt->size=%d ,st->codec->bit_rate =%d\n",__FUNCTION__,__LINE__,st->time_base.den,st->time_base.num,cherry_duration_from_bitrate[cherry_index+1],pkt->size,st->codec->bit_rate );                            
                        
                        }
                        if((cherry_index + 1)> cherry_max_index_of_array) {
                            
                            cherry_max_index_of_array = cherry_index + 1;
                            
                        }
                        //av_log(NULL,AV_LOG_INFO,"cherry_index = %d, duration of the pkt = %lld  , pkt->size =%d \n", cherry_index , cherry_duration_from_bitrate[cherry_index], pkt->size);
                        pkt->dts = cherry_duration_from_bitrate[cherry_index] * st->time_base.den / st->time_base.num / AV_TIME_BASE;
                        //av_log(NULL,AV_LOG_INFO,"st->codec->bit_rate = %d,pkt->dts =%lld ,st->time_base.den=%d,st->time_base.num=%d \n", st->codec->bit_rate,pkt->dts,st->time_base.den,st->time_base.num);
                        av_log(NULL,AV_LOG_INFO,"[%s][%d] dts = %lld \n",__FUNCTION__ , __LINE__ ,pkt->dts);
                        
                    }
                    
                }
            }
#endif
//av_log(s, AV_LOG_DEBUG, "dts:%"PRId64" offset:%"PRId64" %d/%d smpl_siz:%d base:%d st:%d size:%d\n", pkt->dts, ast->frame_offset, ast->scale, ast->rate, ast->sample_size, AV_TIME_BASE, avi->stream_index, size);
//av_log(NULL, AV_LOG_INFO, "dts:%"PRId64" offset:%"PRId64" %d/%d smpl_siz:%d base:%d st:%d size:%d\n", pkt->dts, ast->frame_offset, ast->scale, ast->rate, ast->sample_size, AV_TIME_BASE, avi->stream_index, size);
            pkt->stream_index = avi->stream_index;

            if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
                AVIndexEntry *e;
                int index;
                //assert(st->index_entries);
                if(!st->index_entries) {
			av_log(NULL,AV_LOG_INFO,"terminate avi demuxing : something is wrong... \n");
			return AVERROR_INVALIDDATA;
                }

                index= av_index_search_timestamp(st, ast->frame_offset, 0);
                e= &st->index_entries[index];

                if(index >= 0 && e->timestamp == ast->frame_offset){
                    if (e->flags & AVINDEX_KEYFRAME)
                        pkt->flags |= PKT_FLAG_KEY;
                }
            } else {
                pkt->flags |= PKT_FLAG_KEY;
            }
            if(ast->sample_size)
                ast->frame_offset += pkt->size;
            else {
                ast->frame_offset++;
                //av_log(NULL,AV_LOG_INFO,"[%s][%d] frame_offset =%lld , pkt->size=%d size=%d\n" , __FUNCTION__ , __LINE__ , ast->frame_offset ,pkt->size, size);
            }
        }
        ast->remaining -= size;
        if(!ast->remaining){
            avi->stream_index= -1;
            ast->packet_size= 0;
        }
        if(st->codec->codec_type == CODEC_TYPE_VIDEO) {
            last_video_pkt_timestamp = pkt->dts;
        }

        //av_log(NULL,AV_LOG_INFO,"\n [avi_read] return size = %d ..\n",size);
        return size;
    }


    int no_detected_count;
    no_detected_count = 0;
	
    memset(d, -1, sizeof(int)*8);
    for(i=sync=url_ftell(pb); !url_feof(pb); i++) {
        int j;

	no_detected_count ++;
	//av_log(NULL,AV_LOG_INFO,"no_detected_count = %d \n",no_detected_count);

#ifdef __TRIDENT_SPECIFIC
	if(no_detected_count > (20971520)) { // 20 MByte
		av_log(NULL,AV_LOG_INFO,"something is wrong... maybe broken file. quit seaching..\n");
		return AVERROR_INVALIDDATA;
	}
#endif

        for(j=0; j<7; j++)
            d[j]= d[j+1];
        d[7]= get_byte(pb);

        size= d[4] + (d[5]<<8) + (d[6]<<16) + (d[7]<<24);
        //av_log(NULL,AV_LOG_INFO,"start sync loop : size = %d \n",size);
        n= get_stream_idx(d+2);
//av_log(s, AV_LOG_DEBUG, "%X %X %X %X %X %X %X %X %"PRId64" %d %d\n", d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n);
        if(i + (uint64_t)size > avi->fsize || d[0]<0)
            continue;

        //parse ix##
        if(  (d[0] == 'i' && d[1] == 'x' && n < s->nb_streams)
        //parse JUNK
           ||(d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K')
           ||(d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1')){
                //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);
		no_detected_count = 0;//reset count
            //av_log(NULL,AV_LOG_INFO,"detect ##dd chunk \n");          
            url_fskip(pb, size);
//av_log(s, AV_LOG_DEBUG, "SKIP\n");
            goto resync;
        }
#ifdef Uniplayer_DRM//**********************************************************for Divx DRM
	 if(s->Is_This_DRM_File == 1)
	 {
		if((d[2]=='d' && d[3] =='d'))
		{
                       //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);			
                       no_detected_count = 0;//reset count
                       
                    //av_log(NULL,AV_LOG_INFO,"detect ##dd chunk \n");          
			//av_log(NULL,AV_LOG_INFO,"\n[Divx Drm]##### This is ##DD Chunk of DRM packet \n");

			if(s->samsung_divx == 0) {
				num = s->Write_point;
				s->DRM_information[num].DRM_Key_Index =  get_byte(pb) + (get_byte(pb) << 8);
				s->DRM_information[num].DRM_Offset = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24); 
				s->DRM_information[num].DRM_Length = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
				s->Write_point++;
				if(s->Write_point > 39)
				{
					s->Write_point = 0;
				}

				//pkt->sDRMinfo.DRM_Key_Index = get_byte(pb) + (get_byte(pb) << 8);
				//pkt->sDRMinfo.DRM_Offset = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24); 
				//pkt->sDRMinfo.DRM_Length = get_byte(pb) + (get_byte(pb) <<8) + (get_byte(pb) <<16) + (get_byte(pb) <<24);
				pkt->sDRMinfo.DRM_Key_Index = s->DRM_information[num].DRM_Key_Index ;
				pkt->sDRMinfo.DRM_Offset = s->DRM_information[num].DRM_Offset; 
				pkt->sDRMinfo.DRM_Length = s->DRM_information[num].DRM_Length;
				pkt->sDRMinfo.DRM_Updated_Flag = 1;
			} else {
				
				
			}
			//av_log(NULL, AV_LOG_INFO, "\n[Divx Drm]==== Packet DTS %lld\n", pkt->dts);								
			//av_log(NULL, AV_LOG_INFO, "\n[Divx Drm]==== Index %d Offset %d\n", pkt->sDRMinfo.DRM_Key_Index, pkt->sDRMinfo.DRM_Offset);	
                    goto resync;
            		//continue;
		}

	 }
#endif//**************************************************************************for Divx DRM

        //parse stray LIST
        if(d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T'){
            //av_log(NULL,AV_LOG_INFO,"parse stray LIST \n");
            //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);            
            no_detected_count = 0;//reset count            
            url_fskip(pb, 4);
            goto resync;
        }

        n= get_stream_idx(d);

        if(!((i-avi->last_pkt_pos)&1) && get_stream_idx(d+1) < s->nb_streams)
            continue;

        //detect ##ix chunk and skip
        if(d[2] == 'i' && d[3] == 'x' && n < s->nb_streams){
           // av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);			
            no_detected_count = 0;//reset count			
            //av_log(NULL,AV_LOG_INFO,"detect ##ix chunk and skip \n");
            url_fskip(pb, size);
            goto resync;
        }

        //parse ##dc/##wb
        if(n < s->nb_streams){
            //av_log(NULL,AV_LOG_INFO,"parse ##dc/##wb \n");
            AVStream *st;
            AVIStream *ast;
            st = s->streams[n];
            ast = st->priv_data;

            if(s->nb_streams>=2){
                AVStream *st1  = s->streams[1];
                AVIStream *ast1= st1->priv_data;
                //workaround for broken small-file-bug402.avi
                if(   d[2] == 'w' && d[3] == 'b'
                   && n==0
                   && st ->codec->codec_type == CODEC_TYPE_VIDEO
                   && st1->codec->codec_type == CODEC_TYPE_AUDIO
                   && ast->prefix == 'd'*256+'c'
                   && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)
                  ){
                    //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);                  
                    no_detected_count = 0;//reset count                  
                    n=1;
                    st = st1;
                    ast = ast1;
                    av_log(s, AV_LOG_WARNING, "Invalid stream + prefix combination, assuming audio.\n");
                }
            }


            if(   (st->discard >= AVDISCARD_DEFAULT && size==0)
               /*|| (st->discard >= AVDISCARD_NONKEY && !(pkt->flags & PKT_FLAG_KEY))*/ //FIXME needs a little reordering
               || st->discard >= AVDISCARD_ALL){
                //av_log(NULL, AV_LOG_INFO, "[%s][%d]   st->discard=%d , size = %d st->index = %d \n",__FUNCTION__,__LINE__,st->discard,size, st->index);                                 


                /**
                    M10.divx bug fix : at the end of the file,there are a lot of null chunks (over 1000) It comsume lots of resources of system.
                                             so, compare last dts with index table and decide terminate or not.
                */
                if((avi_index_believable == 1) && !(s->pb->is_streamed) && (avi->movi_end < i)&& (st->nb_index_entries > 100) && (last_video_pkt_timestamp == st->index_entries[st->nb_index_entries -1].timestamp)) {
                   if(!ast->sample_size && st->codec && st->codec->codec_type == CODEC_TYPE_VIDEO) {
                        av_log(NULL,AV_LOG_INFO,"[%s][%d] !!!! Video Pkt End So set eof. !!!! \n",__FUNCTION__,__LINE__);
                        s->pb->eof_reached = 1;
                    }
                }                
                
                if(ast->sample_size) ast->frame_offset += pkt->size;
                else  {
                    ast->frame_offset++;
                }
                url_fskip(pb, size);
                goto resync;
            }

            if (d[2] == 'p' && d[3] == 'c' && size<=4*256+4) {
				
                //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);				
		no_detected_count = 0;//reset count
		
                int k = get_byte(pb);
                int last = (k + get_byte(pb) - 1) & 0xFF;

                get_le16(pb); //flags

                for (; k <= last; k++)
                    ast->pal[k] = get_be32(pb)>>8;// b + (g << 8) + (r << 16);
                ast->has_pal= 1;
                goto resync;
            } else if(   ((ast->prefix_count<5 || sync+9 > i) && d[2]<128 && d[3]<128) ||
                         d[2]*256+d[3] == ast->prefix /*||
                         (d[2] == 'd' && d[3] == 'c') ||
                         (d[2] == 'w' && d[3] == 'b')*/) {

                //av_log(NULL,AV_LOG_INFO,"avi reset [%d][%d]\n",__LINE__ ,no_detected_count);                         
		no_detected_count = 0;//reset count                         

//av_log(s, AV_LOG_DEBUG, "OK\n");
                if(d[2]*256+d[3] == ast->prefix)
                    ast->prefix_count++;
                else{
                    ast->prefix= d[2]*256+d[3];
                    ast->prefix_count= 0;
                }

                avi->stream_index= n;
                ast->packet_size= size + 8;
                ast->remaining= size;
                //av_log(NULL,AV_LOG_INFO,"[ ##%c%c ] avi->stream_index = %d , ast->packet_size=%d\n",d[2],d[3],avi->stream_index , ast->packet_size);
                if(size || !ast->sample_size){
                    uint64_t pos= url_ftell(pb) - 8;
                    if(!st->index_entries || !st->nb_index_entries || st->index_entries[st->nb_index_entries - 1].pos < pos){
                        if(!avi_simple_index_load) {
                        av_add_index_entry(st, pos, ast->frame_offset, size, 0, AVINDEX_KEYFRAME);
                    }
                }
                }
                goto resync;
            }
        }
    }
    //av_log(NULL,AV_LOG_INFO,"[%s][%d] EOF \n",__FUNCTION__,__LINE__);
    return AVERROR_EOF;
}

/* XXX: We make the implicit supposition that the positions are sorted
   for each stream. */
static int avi_read_idx1(AVFormatContext *s, int size)
{
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    int nb_index_entries, i;
    AVStream *st;
    AVIStream *ast;
    unsigned int index, tag, flags, pos, len;
    unsigned last_pos= -1;
    int64_t dd_chunk_pos = AV_NOPTS_VALUE;

    int k;
    for(k=0;k<s->nb_streams;k++) {
        s->streams[k]->nb_original_index_entries = 0;
    }    

    nb_index_entries = size / 16;
    if (nb_index_entries <= 0)
        return -1;
    av_log(NULL,AV_LOG_INFO,"[%s][%d] Load Old Style Idx1 table..nb_index_entries = %d \n",__FUNCTION__,__LINE__,nb_index_entries);
    /* Read the entries and sort them in each stream component. */
    for(i = 0; i < nb_index_entries; i++) {
        tag = get_le32(pb);
        flags = get_le32(pb);
        pos = get_le32(pb);
        len = get_le32(pb);
#if defined(DEBUG_SEEK)
        av_log(s, AV_LOG_DEBUG, "%d: tag=0x%x flags=0x%x pos=0x%x len=%d/",
               i, tag, flags, pos, len);
#endif
        //av_log(NULL,AV_LOG_INFO,"[%s] tag=%c%c%c%c (0x%x)\n",__FUNCTION__,tag & 0xff,(tag >> 8) & 0xff,(tag >> 16) & 0xff,(tag >> 24) & 0xff,tag);
        if(i==0 && pos > avi->movi_list)
            avi->movi_list= 0; //FIXME better check
        pos += avi->movi_list;

        index = ((tag & 0xff) - '0') * 10;
        index += ((tag >> 8) & 0xff) - '0';
        if (index >= s->nb_streams)
            continue;
        st = s->streams[index];
        ast = st->priv_data;

#if defined(DEBUG_SEEK)
        av_log(s, AV_LOG_DEBUG, "%d cum_len=%"PRId64"\n", len, ast->cum_len);
#endif
        if(url_feof(pb))
            return -1;

        if(last_pos == pos)
            avi->non_interleaved= 1;
        else if(avi_simple_index_load) {
            // load only video index
            //av_log(NULL,AV_LOG_INFO,"tag= XX%c%c \n",((tag >> 16) & 0xff),((tag >> 24) & 0xff));
            if(!ast->sample_size &&(((tag >> 16) & 0xff) == 'd' ) && (((tag >> 24) & 0xff) == 'c' )) {
                // 0x64643030 = dd chunk tag
                if((flags&AVIIF_INDEX)) {
			av_add_index_entry(st, pos, ast->cum_len, len, 0, AVINDEX_KEYFRAME);
		}
		else 	if(!(st->nb_original_index_entries % 2)) {
			av_add_index_entry(st, pos, ast->cum_len, len, 0, 0);
		}
            } else {       
                // reduce table size to 1/10 * original size.
                if(!(st->nb_original_index_entries % 10)) {
                    av_add_index_entry(st,pos, ast->cum_len, len, 0, (flags&AVIIF_INDEX) ? AVINDEX_KEYFRAME : 0);
                }
            }
        }
        else if(len || !ast->sample_size) {
            // 0x64643030 = dd chunk tag
            if(tag == 0x64643030 && (dd_chunk_pos == AV_NOPTS_VALUE)) {
                dd_chunk_pos = pos;
            }
            if(tag != 0x64643030) {
                if(len != 0) {
                av_add_index_entry(st, (dd_chunk_pos !=AV_NOPTS_VALUE? dd_chunk_pos: pos), ast->cum_len, len, 0, (flags&AVIIF_INDEX) ? AVINDEX_KEYFRAME : 0);
                } else if(len == 0) {
                	av_add_index_entry(st, (dd_chunk_pos !=AV_NOPTS_VALUE? dd_chunk_pos: pos), ast->cum_len, len, 0,  0);
                }
				
                dd_chunk_pos = AV_NOPTS_VALUE;
            }
        }
        
        if(ast->sample_size)
            ast->cum_len += len;
        else {
            // 0x64643030 = dd chunk tag
            if(tag != 0x64643030)ast->cum_len++;
        }
        
        if(avi_simple_index_load) {
            st->nb_original_index_entries++;
        }
        last_pos= pos;
    }
    return 0;
}

static int guess_ni_flag(AVFormatContext *s){
    int i;
    int64_t last_start=0;
    int64_t first_end= INT64_MAX;
    int64_t oldpos= url_ftell(s->pb);

    for(i=0; i<s->nb_streams; i++){
        AVStream *st = s->streams[i];
        int n= st->nb_index_entries;
        unsigned int size;

        if(n <= 0)
            continue;

        if(n >= 2){
            int64_t pos= st->index_entries[0].pos;
            url_fseek(s->pb, pos + 4, SEEK_SET);
            size= get_le32(s->pb);
            if(pos + size > st->index_entries[1].pos)
                last_start= INT64_MAX;
        }

        if(st->index_entries[0].pos > last_start)
            last_start= st->index_entries[0].pos;
        if(st->index_entries[n-1].pos < first_end)
            first_end= st->index_entries[n-1].pos;
    }
    url_fseek(s->pb, oldpos, SEEK_SET);
    return last_start > first_end;
}

static int avi_load_index(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    ByteIOContext *pb = s->pb;
    uint32_t tag, size;
    int64_t pos= url_ftell(pb);
    int ret = -1;

    if (url_fseek(pb, avi->movi_end, SEEK_SET) < 0)
        goto the_end; // maybe truncated file
#ifdef DEBUG_SEEK
    printf("movi_end=0x%"PRIx64"\n", avi->movi_end);
#endif
    for(;;) {
        if (url_feof(pb))
            break;
        tag = get_le32(pb);
        size = get_le32(pb);
#ifdef DEBUG_SEEK
        printf("tag=%c%c%c%c size=0x%x\n",
               tag & 0xff,
               (tag >> 8) & 0xff,
               (tag >> 16) & 0xff,
               (tag >> 24) & 0xff,
               size);
#endif
        switch(tag) {
        case MKTAG('i', 'd', 'x', '1'):
            av_log(NULL,AV_LOG_INFO,"[%s][%d] There are IDX1 chunk...\n",__FUNCTION__,__LINE__);
            if (avi_read_idx1(s, size) < 0)
                goto skip;
            ret = 0;
                goto the_end;
            break;
        default:
        skip:
            size += (size & 1);
            if (url_fseek(pb, size, SEEK_CUR) < 0)
                goto the_end; // something is wrong here
            break;
        }
    }
 the_end:
    url_fseek(pb, pos, SEEK_SET);
    return ret;
}

static int avi_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
{
    AVIContext *avi = s->priv_data;
    AVStream *st;
    int i, index;
    int64_t pos;
    AVIStream *ast;
   // av_log(NULL,AV_LOG_INFO,"[%s][%d] stream_index=%d , timestamp = %lld ,flags=%d \n",__FUNCTION__,__LINE__,stream_index, timestamp , flags);
    if (!avi->index_loaded) {
        /* we only load the index on demand */
        avi_load_index(s);
        avi->index_loaded = 1;
    }
    assert(stream_index>= 0);

    st = s->streams[stream_index];
    ast= st->priv_data;
    index= av_index_search_timestamp(st, timestamp * FFMAX(ast->sample_size, 1), flags);
    if(index<0) {
        av_log(NULL,AV_LOG_INFO,"[%s][%d] Target TS<%lld> flag<%d> Fail to find the wanted_timestamp.. demuxer seek is failed.\n",__FUNCTION__,__LINE__,timestamp * FFMAX(ast->sample_size, 1),flags);
#if 0 // compute timestamp by vbr and size
        for(i = 0; i < s->nb_streams; i++) {
            AVStream *st2 = s->streams[i];
            if(st2->search_timestamp_from_bitrate == 333) {
                return  -777; // do not try generic seek.
            }
        }
#endif        
        return -1;
    }
    /* find the position */
    pos = st->index_entries[index].pos;
    timestamp = st->index_entries[index].timestamp / FFMAX(ast->sample_size, 1);
//    av_log(NULL,AV_LOG_INFO,"[%s][%d] index=%d , timestamp = %lld \n",__FUNCTION__,__LINE__, index, timestamp);
//    av_log(s, AV_LOG_DEBUG, "XX %"PRId64" %d %"PRId64"\n", timestamp, index, st->index_entries[index].timestamp);

    if (CONFIG_DV_DEMUXER && avi->dv_demux) {
        /* One and only one real stream for DV in AVI, and it has video  */
        /* offsets. Calling with other stream indexes should have failed */
        /* the av_index_search_timestamp call above.                     */
        assert(stream_index == 0);

        /* Feed the DV video stream version of the timestamp to the */
        /* DV demux so it can synthesize correct timestamps.        */
        dv_offset_reset(avi->dv_demux, timestamp);

        url_fseek(s->pb, pos, SEEK_SET);
        avi->stream_index= -1;
        return 0;
    }

//PRINT INDEX ENTRIES#i
#if 0
   av_log(NULL,AV_LOG_INFO,"\nPRINT INDEX ENTRIES! (1) [%d]\n",st->nb_index_entries);
    if(1) {
        int j;
        for(j = 0; j < s->nb_streams; j++) {        
        int i=0;
            AVStream *st = s->streams[j];
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);            
        for(i=0;i<st->nb_index_entries;i++) {
            av_log(NULL,AV_LOG_INFO,"POS[%lld],TS[%lld], FLAGS[%d],SIZE[%d],MIN_DISTANCE[%d]\n"
                ,st->index_entries[i].pos
                ,st->index_entries[i].timestamp
                ,st->index_entries[i].flags
                ,st->index_entries[i].size
                ,st->index_entries[i].min_distance);
        }
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);            
        }
    }
 #endif

    for(i = 0; i < s->nb_streams; i++) {
        AVStream *st2 = s->streams[i];
        AVIStream *ast2 = st2->priv_data;

        ast2->packet_size=
        ast2->remaining= 0;

        if (st2->nb_index_entries <= 0)
            continue;

//        assert(st2->codec->block_align);
        assert((int64_t)st2->time_base.num*ast2->rate == (int64_t)st2->time_base.den*ast2->scale);
#if 0 // compute timestamp by vbr and size
        if(st2->search_timestamp_from_bitrate == 333) {
         
            int k;
            #if 0 //debug_  print index array
            av_log(NULL,AV_LOG_INFO,"[%s][%d] *************** Seek is called !!! wanted video timestamp = %lld, max index array=%d \n",__FUNCTION__,__LINE__, timestamp ,cherry_max_index_of_array);
            for(k=0;k<cherry_max_index_of_array;k++) {
                av_log(NULL,AV_LOG_INFO,"index[%d] timestamp[%lld]\n",k,cherry_duration_from_bitrate[k]);
            }
            #endif
            //find timestamp
            int64_t cherry_wanted_timestamp_in_microsec = (timestamp * st->time_base.num /st->time_base.den * AV_TIME_BASE);
            //av_log(NULL,AV_LOG_INFO,"cherry_wanted_timestamp_in_microsec  = %lld , timestamp=%lld\n",cherry_wanted_timestamp_in_microsec ,timestamp);

            if(cherry_wanted_timestamp_in_microsec > cherry_duration_from_bitrate[cherry_max_index_of_array]) {
                av_log(NULL,AV_LOG_INFO,"\n[%s][%d] Out Of Bound so, let's try to find index..wanted =%lld ,max_have = %lld , max_index = %d \n",__FUNCTION__,__LINE__,cherry_wanted_timestamp_in_microsec,cherry_duration_from_bitrate[cherry_max_index_of_array],cherry_max_index_of_array);
                AVPacket pkt;
                int temp_TryCount=0;
                for(i=0;; i++) {
                    int ret;
                    //av_log(NULL,AV_LOG_INFO,"[%s][%d] TryCount (%d)\n",__FUNCTION__,__LINE__,temp_TryCount);
                    temp_TryCount++;
                    do{
                        ret = av_read_frame(s, &pkt);
//                        ret = avi_read_packet(s,&pkt);
                        //av_log(NULL,AV_LOG_INFO,"[%s][%d] cherry_max_index_of_array = %d ,cherry_duration_from_bitrate[cherry_max_index_of_array] =%lld , count = %d \n",__FUNCTION__,__LINE__,cherry_max_index_of_array,cherry_duration_from_bitrate[cherry_max_index_of_array], temp_TryCount);
                    }while((ret >=0) && (cherry_wanted_timestamp_in_microsec > cherry_duration_from_bitrate[cherry_max_index_of_array]));
                    if(ret<0)
                        break;
                    av_free_packet(&pkt);

                    if(cherry_wanted_timestamp_in_microsec <= cherry_duration_from_bitrate[cherry_max_index_of_array])
                    {
                        av_log(NULL,AV_LOG_INFO,"[%s][%d] Gotcha!!!!!!!!!!!!index[%d] timestamp[%lld]\n",__FUNCTION__,__LINE__,cherry_max_index_of_array,cherry_duration_from_bitrate[cherry_max_index_of_array]);
                        index = cherry_max_index_of_array;
                        break;
                    }
                }
            } else {
                for(k=0;k< cherry_max_index_of_array;k++) {

                    if( cherry_duration_from_bitrate[k] > 0 && cherry_wanted_timestamp_in_microsec > cherry_duration_from_bitrate[k]) {
                        
                        continue;
                        
                    } else if(cherry_wanted_timestamp_in_microsec <= cherry_duration_from_bitrate[k]){
                    
                        index = k;
                        //av_log(NULL,AV_LOG_INFO,"founded index[%d] timestamp[%lld]\n",index,cherry_duration_from_bitrate[k]);
                        break;
                        
                    }
                }            
            }
        }
        else 
#endif      

        if(use_index_for_sync == 77) {
            // divx certification for E21 & C24 clips            
            // estimate audio timestamp
            // audio target index = video target index * (A timebase / V timebase)

            int video_index;
            int audio_index;
            video_index = index;

            //audio_index = video_index * (st->time_base.num / st->time_base.den) / (st2->time_base.num / st2->time_base.den);
            audio_index = av_rescale_q(video_index, st->time_base, st2->time_base); // video index == video timestamp
            index = audio_index;
        }else
        if(st2->codec->codec_type != CODEC_TYPE_SUBTITLE) {
            index = av_index_search_timestamp(
                    st2,
                    av_rescale_q(timestamp, st->time_base, st2->time_base) * FFMAX(ast2->sample_size, 1),
                    flags | AVSEEK_FLAG_ANY);
        }else  {
        // for subtitle
            index = av_index_search_timestamp(
                    st2,
                    0,
                    flags | AVSEEK_FLAG_ANY);   
        }

        if(index<0)
            index=0;

        if(!avi->non_interleaved){
            while(index>0 && st2->index_entries[index].pos > pos)
                index--;
            while(index+1 < st2->nb_index_entries && st2->index_entries[index].pos < pos)
                index++;
        }

//        av_log(s, AV_LOG_DEBUG, "%"PRId64" %d %"PRId64"\n", timestamp, index, st2->index_entries[index].timestamp);
        /* extract the current frame number */
        ast2->frame_offset = st2->index_entries[index].timestamp;
    }

    /* do the seek */
    url_fseek(s->pb, pos, SEEK_SET);
    avi->stream_index= -1;
    return 0;
}

static int avi_read_close(AVFormatContext *s)
{
    int i;
    AVIContext *avi = s->priv_data;

    for(i=0;i<s->nb_streams;i++) {
        AVStream *st = s->streams[i];
        av_free(st->codec->palctrl);
    }

    if (avi->dv_demux)
        av_free(avi->dv_demux);

    return 0;
}

static int avi_probe(AVProbeData *p)
{
    int i;

    /* check file header */
    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(p->buf  , avi_headers[i]  , 4) &&
           !memcmp(p->buf+8, avi_headers[i]+4, 4))
            return AVPROBE_SCORE_MAX;

    return 0;
}


/**
    return 0; invalid
    return 1; valid
*/
int is_valid_avi_indextable(AVStream *st , int64_t wanted_timestamp)
{

    if(st == NULL) {
        return 0;
    }
    
    if(!st->index_entries) {
        return 0; //invalid
    }

    av_log(NULL,AV_LOG_INFO,"[%s][%d] st->nb_index_entries =%d \n",__FUNCTION__,__LINE__,st->nb_index_entries);
    if(st->nb_index_entries < 5) {
        return 0; // invalid
    }

    if((wanted_timestamp >0) && (wanted_timestamp != AV_NOPTS_VALUE) && st->nb_index_entries > 0)
    {
        if((wanted_timestamp + 10) > (st->index_entries[st->nb_index_entries - 1].timestamp * 2))
        {
            return 0;
        }
    }


/** Count size=0 index entries
*/
/*
    int nb_valid_index = 0;
    int i;
    for(i=0; i<st->nb_index_entries; i++)
    {
        if(st->index_entries[i].size != 0) {
            nb_valid_index++;
        }
    }
    av_log(NULL,AV_LOG_INFO,"[%s][%d] nb_valid_index =%d \n",__FUNCTION__,__LINE__,nb_valid_index);    
    if(nb_valid_index < 2) {
        return 0;//invalid
    }

*/

    // check ts
/*
    if(st->index_entries[st->nb_index_entries -1].timestamp < (wanted_timestamp / 100) )
    {
        return 0;//invalid
    }
*/

    return 1;

}

extern int avi_seek_available(AVFormatContext *s, int stream_index, int64_t wanted_timestamp, int flags) 
{
    
#if 0
    if(1) {
        int j;
        for(j = 0; j < s->nb_streams; j++) {        
        int i=0;
            AVStream *st = s->streams[j];
            av_log(NULL,AV_LOG_INFO,"\nPRINT INDEX ENTRIES! (1) [%d]\n",st->nb_index_entries);            
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
            
            switch(st->codec->codec_type) {
                case CODEC_TYPE_VIDEO:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE VIDEO\n\n");
                    break;
                case CODEC_TYPE_AUDIO:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE AUDIO\n\n");
                    break;
                default:
                    av_log(NULL,AV_LOG_INFO,"\n CODEC TYPE ELSE\n\n");
                    break;
            }
            
        for(i=0;i<st->nb_index_entries;i++) {
            av_log(NULL,AV_LOG_INFO,"POS[%lld],TS[%lld], FLAGS[%d],SIZE[%d],MIN_DISTANCE[%d]\n"
                ,st->index_entries[i].pos
                ,st->index_entries[i].timestamp
                ,st->index_entries[i].flags
                ,st->index_entries[i].size
                ,st->index_entries[i].min_distance);
        }
            av_log(NULL,AV_LOG_INFO,"*************************INDEX TABLE [STREAM INDEX = %d]***********************\n",j);
        }
    }
#endif
    
    if(!is_valid_avi_indextable(s->streams[stream_index] , wanted_timestamp))
    {
	avi_index_believable = 0;
        return -1; //cannot seek
    }
    avi_index_believable = 1;
    return 0;
    
}


AVInputFormat avi_demuxer = {
    "avi",
    NULL_IF_CONFIG_SMALL("AVI format"),
    sizeof(AVIContext),
    avi_probe,
    avi_read_header,
    avi_read_packet,
    avi_read_close,
    avi_read_seek,
};
